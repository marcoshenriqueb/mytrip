/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/static/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.7.1\n\n/*\n Paraxify.js - v0.1\n @author Jaime Caballero\n MIT license\n */\n(function(document, window, index) {\n  \"use strict\";\n  var paraxify;\n  paraxify = function(el, options) {\n    var Paraxify, contador, i, opt, pho, posY, screenY;\n    posY = 0;\n    screenY = 0;\n    i = 0;\n    opt = {};\n    pho = [];\n    contador = 0;\n    Paraxify = function(el, options) {\n      this.options = {\n        speed: 1,\n        boost: 0\n      };\n      for (i in options) {\n        this.options[i] = options[i];\n      }\n      if (this.options.speed < 0 || this.options.speed > 1) {\n        this.options.speed = 1;\n      }\n      if (!el) {\n        el = 'paraxify';\n      }\n      if (document.getElementsByClassName(el.replace('.', ''))) {\n        this.photos = document.getElementsByClassName(el.replace('.', ''));\n      } else if (document.querySelector(el) !== false) {\n        this.photos = querySelector(el);\n      } else {\n        throw new Error(\"The elements you're trying to select don't exist.\");\n      }\n      opt = this.options;\n      pho = this.photos;\n      this._init(this);\n    };\n    Paraxify.prototype = {\n      update: function() {\n        screenY = window.innerHeight;\n        i = 0;\n        while (i < pho.length) {\n          pho[i].style.backgroundPosition = \"center center\";\n          pho[i].url = window.getComputedStyle(pho[i], false).backgroundImage.replace(/url\\((['\"])?(.*?)\\1\\)/gi, '$2').split(',')[0];\n          if (!pho[i].img) {\n            pho[i].img = new Image();\n          }\n          if (pho[i].url !== pho[i].img.src) {\n            this._check(i);\n            pho[i].img.src = pho[i].url;\n          }\n          i++;\n        }\n        this._animate();\n      },\n      _init: function() {\n        this.update();\n        window.onscroll = (function() {\n          this._animate();\n        }).bind(this);\n        window.onresize = (function() {\n          this.update();\n        }).bind(this);\n      },\n      _check: function(i) {\n        var actualHeight, main;\n        main = pho[i];\n        main.ok = true;\n        main.bgSize = window.getComputedStyle(main, false).backgroundSize;\n        actualHeight = screenY;\n        pho[i].img.onload = function() {\n          if (main.bgSize === '' || main.bgSize === 'auto') {\n            if (this.height < main.offsetHeight) {\n              main.ok = false;\n              throw new Error(\"The image \" + main.url + \" (\" + this.height + \"px) is too short for that container (\" + main.offsetHeight + \"px).\");\n            } else {\n              actualHeight = this.height;\n              if (this.height < screenY) {\n                actualHeight = actualHeight + ((screenY - main.offsetHeight) * opt.speed);\n              }\n            }\n          } else if (main.bgSize === 'cover') {\n            if (screenY < main.offsetHeight) {\n              main.ok = false;\n              throw new Error(\"The container (\" + main.offsetHeight + \"px) can't be bigger than the image (\" + screenY + \"px).\");\n            }\n          } else {\n            window.getComputedStyle(main, false).backgroundSize === 'cover';\n            this._check(i);\n          }\n          main.diff = -(actualHeight - main.offsetHeight) * opt.speed;\n          main.diff = main.diff - (main.offsetHeight * opt.boost);\n        };\n      },\n      _visible: function(i) {\n        if (((posY + screenY) > pho[i].offsetTop) && (posY < pho[i].offsetTop + pho[i].offsetHeight)) {\n          return true;\n        }\n        return false;\n      },\n      _animate: function() {\n        var per, position;\n        if (window.pageYOffset !== void 0) {\n          posY = window.pageYOffset;\n        } else {\n          posY = (document.documentElement || document.body.parentNode || document.body).scrollTop;\n        }\n        i = 0;\n        while (i < pho.length) {\n          this._check(i);\n          if (pho[i].ok && window.getComputedStyle(pho[i], false).backgroundAttachment === \"fixed\" && this._visible(i)) {\n            per = (posY - pho[i].offsetTop + screenY) / (pho[i].offsetHeight + screenY);\n            position = pho[i].diff * (per - 0.5);\n            if (pho[i].bgSize !== 'cover') {\n              position = position + ((screenY - pho[i].img.height) / 2);\n            }\n            position = Math.round(position * 100) / 100;\n          } else {\n            position = \"center\";\n          }\n          pho[i].style.backgroundPosition = \"center \" + position + \"px\";\n          i++;\n        }\n      }\n    };\n    return new Paraxify(el, options);\n  };\n  window.paraxify = paraxify;\n})(document, window, 0);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2hvbWUvc3RhdGljL2hvbWUvanMvcGFyYXhpZnkuanM/N2E3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG5cbi8qXG4gUGFyYXhpZnkuanMgLSB2MC4xXG4gQGF1dGhvciBKYWltZSBDYWJhbGxlcm9cbiBNSVQgbGljZW5zZVxuICovXG4oZnVuY3Rpb24oZG9jdW1lbnQsIHdpbmRvdywgaW5kZXgpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBwYXJheGlmeTtcbiAgcGFyYXhpZnkgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgIHZhciBQYXJheGlmeSwgY29udGFkb3IsIGksIG9wdCwgcGhvLCBwb3NZLCBzY3JlZW5ZO1xuICAgIHBvc1kgPSAwO1xuICAgIHNjcmVlblkgPSAwO1xuICAgIGkgPSAwO1xuICAgIG9wdCA9IHt9O1xuICAgIHBobyA9IFtdO1xuICAgIGNvbnRhZG9yID0gMDtcbiAgICBQYXJheGlmeSA9IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNwZWVkOiAxLFxuICAgICAgICBib29zdDogMFxuICAgICAgfTtcbiAgICAgIGZvciAoaSBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNwZWVkIDwgMCB8fCB0aGlzLm9wdGlvbnMuc3BlZWQgPiAxKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zcGVlZCA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIGVsID0gJ3BhcmF4aWZ5JztcbiAgICAgIH1cbiAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGVsLnJlcGxhY2UoJy4nLCAnJykpKSB7XG4gICAgICAgIHRoaXMucGhvdG9zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShlbC5yZXBsYWNlKCcuJywgJycpKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucGhvdG9zID0gcXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZWxlbWVudHMgeW91J3JlIHRyeWluZyB0byBzZWxlY3QgZG9uJ3QgZXhpc3QuXCIpO1xuICAgICAgfVxuICAgICAgb3B0ID0gdGhpcy5vcHRpb25zO1xuICAgICAgcGhvID0gdGhpcy5waG90b3M7XG4gICAgICB0aGlzLl9pbml0KHRoaXMpO1xuICAgIH07XG4gICAgUGFyYXhpZnkucHJvdG90eXBlID0ge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2NyZWVuWSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgcGhvLmxlbmd0aCkge1xuICAgICAgICAgIHBob1tpXS5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBcImNlbnRlciBjZW50ZXJcIjtcbiAgICAgICAgICBwaG9baV0udXJsID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGhvW2ldLCBmYWxzZSkuYmFja2dyb3VuZEltYWdlLnJlcGxhY2UoL3VybFxcKChbJ1wiXSk/KC4qPylcXDFcXCkvZ2ksICckMicpLnNwbGl0KCcsJylbMF07XG4gICAgICAgICAgaWYgKCFwaG9baV0uaW1nKSB7XG4gICAgICAgICAgICBwaG9baV0uaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwaG9baV0udXJsICE9PSBwaG9baV0uaW1nLnNyYykge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2soaSk7XG4gICAgICAgICAgICBwaG9baV0uaW1nLnNyYyA9IHBob1tpXS51cmw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbmltYXRlKCk7XG4gICAgICB9LFxuICAgICAgX2luaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB3aW5kb3cub25zY3JvbGwgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZSgpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgICB3aW5kb3cub25yZXNpemUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBfY2hlY2s6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdmFyIGFjdHVhbEhlaWdodCwgbWFpbjtcbiAgICAgICAgbWFpbiA9IHBob1tpXTtcbiAgICAgICAgbWFpbi5vayA9IHRydWU7XG4gICAgICAgIG1haW4uYmdTaXplID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobWFpbiwgZmFsc2UpLmJhY2tncm91bmRTaXplO1xuICAgICAgICBhY3R1YWxIZWlnaHQgPSBzY3JlZW5ZO1xuICAgICAgICBwaG9baV0uaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChtYWluLmJnU2l6ZSA9PT0gJycgfHwgbWFpbi5iZ1NpemUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0IDwgbWFpbi5vZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgbWFpbi5vayA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgaW1hZ2UgXCIgKyBtYWluLnVybCArIFwiIChcIiArIHRoaXMuaGVpZ2h0ICsgXCJweCkgaXMgdG9vIHNob3J0IGZvciB0aGF0IGNvbnRhaW5lciAoXCIgKyBtYWluLm9mZnNldEhlaWdodCArIFwicHgpLlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFjdHVhbEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPCBzY3JlZW5ZKSB7XG4gICAgICAgICAgICAgICAgYWN0dWFsSGVpZ2h0ID0gYWN0dWFsSGVpZ2h0ICsgKChzY3JlZW5ZIC0gbWFpbi5vZmZzZXRIZWlnaHQpICogb3B0LnNwZWVkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWFpbi5iZ1NpemUgPT09ICdjb3ZlcicpIHtcbiAgICAgICAgICAgIGlmIChzY3JlZW5ZIDwgbWFpbi5vZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgbWFpbi5vayA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29udGFpbmVyIChcIiArIG1haW4ub2Zmc2V0SGVpZ2h0ICsgXCJweCkgY2FuJ3QgYmUgYmlnZ2VyIHRoYW4gdGhlIGltYWdlIChcIiArIHNjcmVlblkgKyBcInB4KS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG1haW4sIGZhbHNlKS5iYWNrZ3JvdW5kU2l6ZSA9PT0gJ2NvdmVyJztcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYWluLmRpZmYgPSAtKGFjdHVhbEhlaWdodCAtIG1haW4ub2Zmc2V0SGVpZ2h0KSAqIG9wdC5zcGVlZDtcbiAgICAgICAgICBtYWluLmRpZmYgPSBtYWluLmRpZmYgLSAobWFpbi5vZmZzZXRIZWlnaHQgKiBvcHQuYm9vc3QpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIF92aXNpYmxlOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIGlmICgoKHBvc1kgKyBzY3JlZW5ZKSA+IHBob1tpXS5vZmZzZXRUb3ApICYmIChwb3NZIDwgcGhvW2ldLm9mZnNldFRvcCArIHBob1tpXS5vZmZzZXRIZWlnaHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIF9hbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBlciwgcG9zaXRpb247XG4gICAgICAgIGlmICh3aW5kb3cucGFnZVlPZmZzZXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHBvc1kgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zWSA9IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBwaG8ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fY2hlY2soaSk7XG4gICAgICAgICAgaWYgKHBob1tpXS5vayAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwaG9baV0sIGZhbHNlKS5iYWNrZ3JvdW5kQXR0YWNobWVudCA9PT0gXCJmaXhlZFwiICYmIHRoaXMuX3Zpc2libGUoaSkpIHtcbiAgICAgICAgICAgIHBlciA9IChwb3NZIC0gcGhvW2ldLm9mZnNldFRvcCArIHNjcmVlblkpIC8gKHBob1tpXS5vZmZzZXRIZWlnaHQgKyBzY3JlZW5ZKTtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gcGhvW2ldLmRpZmYgKiAocGVyIC0gMC41KTtcbiAgICAgICAgICAgIGlmIChwaG9baV0uYmdTaXplICE9PSAnY292ZXInKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gKyAoKHNjcmVlblkgLSBwaG9baV0uaW1nLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uID0gTWF0aC5yb3VuZChwb3NpdGlvbiAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGhvW2ldLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IFwiY2VudGVyIFwiICsgcG9zaXRpb24gKyBcInB4XCI7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFBhcmF4aWZ5KGVsLCBvcHRpb25zKTtcbiAgfTtcbiAgd2luZG93LnBhcmF4aWZ5ID0gcGFyYXhpZnk7XG59KShkb2N1bWVudCwgd2luZG93LCAwKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaG9tZS9zdGF0aWMvaG9tZS9qcy9wYXJheGlmeS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2hvbWUvc3RhdGljL2hvbWUvY3NzL3BhcmF4aWZ5LmNzcz84NjlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ob21lL3N0YXRpYy9ob21lL2Nzcy9wYXJheGlmeS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2hvbWUvc3RhdGljL2hvbWUvc3R5bC9ob21lLnN0eWw/ZTlkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaG9tZS9zdGF0aWMvaG9tZS9zdHlsL2hvbWUuc3R5bFxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzP2EwMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_normalize_css__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_normalize_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_normalize_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_paraxify_css__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_paraxify_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__css_paraxify_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__styl_home_styl__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__styl_home_styl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__styl_home_styl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__js_paraxify__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__js_paraxify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__js_paraxify__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_shufflejs__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_shufflejs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_shufflejs__);\n\n\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    document.getElementById('mobile-menu').addEventListener('click', () => {\n        document.querySelector('header.header').classList.toggle('active');\n    });\n\n\n    const adjustVideo = () => {\n        const w = window.innerWidth;\n        if (w > 768 && top.offsetHeight > v.offsetHeight) {\n            const vRatio = (v.videoHeight - 20) / v.videoWidth;\n            top.style.height = (vRatio * w) + 'px';\n        }\n    }\n\n    const top = document.querySelector('.top');\n    const v = document.getElementsByTagName('video')[0];\n    if (v) {\n        v.addEventListener('loadeddata', () => {\n            adjustVideo();\n        });\n    }\n\n    paraxify('.paraxify');\n\n    const adjustProjectContainers = () => {\n        const w = window.innerWidth;\n        const containers = document.querySelectorAll('.project-container');\n        if (w > 868) {\n            containers.forEach((c) => {\n                c.style.height = (c.querySelector('.project_big img').clientHeight - 2) + 'px';\n            });\n        } else {\n            containers.forEach((c) => {\n                c.style.height = null;\n            });\n        }\n    };\n    adjustProjectContainers();\n\n\n    const grid = document.getElementById('grid');\n    if (grid) {\n        const shuffle = new __WEBPACK_IMPORTED_MODULE_4_shufflejs___default.a(grid, {\n          itemSelector: '.projects-content_item',\n          gutterWidth: 20,\n          columnWidth: (w) => {\n            let width = (w / 3) - 15;\n            if (w < 400) {\n                width = w;\n            } else if (w < 750) {\n                width = (w / 2) - 10;\n            }\n            document.querySelectorAll('.projects-content_item').forEach((item) => {\n                item.style.width = width + 'px';\n                item.style.height = width + 'px';\n            });\n            return width;\n          },\n        });\n        document.querySelectorAll('.project-filter-button').forEach((button) => {\n            button.addEventListener('click', (e) => {\n                e.target.classList.toggle('active');\n                shuffle.filter(e.target.id);\n            })\n        });\n    }\n\n    const onResize = () => {\n        adjustProjectContainers();\n        if (v) {\n            adjustVideo();\n        }\n    };\n    window.onresize = onResize;\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2hvbWUvc3RhdGljL2hvbWUvanMvaG9tZS5qcz8wYzlkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnbm9ybWFsaXplLmNzcyc7XG5pbXBvcnQgJy4vLi4vY3NzL3BhcmF4aWZ5LmNzcyc7XG5pbXBvcnQgJy4vLi4vc3R5bC9ob21lLnN0eWwnO1xuXG5pbXBvcnQgJy4vLi4vanMvcGFyYXhpZnknO1xuaW1wb3J0IFNodWZmbGUgZnJvbSAnc2h1ZmZsZWpzJztcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9iaWxlLW1lbnUnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZGVyLmhlYWRlcicpLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpO1xuICAgIH0pO1xuXG5cbiAgICBjb25zdCBhZGp1c3RWaWRlbyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdyA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBpZiAodyA+IDc2OCAmJiB0b3Aub2Zmc2V0SGVpZ2h0ID4gdi5vZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZSYXRpbyA9ICh2LnZpZGVvSGVpZ2h0IC0gMjApIC8gdi52aWRlb1dpZHRoO1xuICAgICAgICAgICAgdG9wLnN0eWxlLmhlaWdodCA9ICh2UmF0aW8gKiB3KSArICdweCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0b3AgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG9wJyk7XG4gICAgY29uc3QgdiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2aWRlbycpWzBdO1xuICAgIGlmICh2KSB7XG4gICAgICAgIHYuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsICgpID0+IHtcbiAgICAgICAgICAgIGFkanVzdFZpZGVvKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHBhcmF4aWZ5KCcucGFyYXhpZnknKTtcblxuICAgIGNvbnN0IGFkanVzdFByb2plY3RDb250YWluZXJzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB3ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucHJvamVjdC1jb250YWluZXInKTtcbiAgICAgICAgaWYgKHcgPiA4NjgpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcnMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgICAgIGMuc3R5bGUuaGVpZ2h0ID0gKGMucXVlcnlTZWxlY3RvcignLnByb2plY3RfYmlnIGltZycpLmNsaWVudEhlaWdodCAtIDIpICsgJ3B4JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVycy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgYy5zdHlsZS5oZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFkanVzdFByb2plY3RDb250YWluZXJzKCk7XG5cblxuICAgIGNvbnN0IGdyaWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ3JpZCcpO1xuICAgIGlmIChncmlkKSB7XG4gICAgICAgIGNvbnN0IHNodWZmbGUgPSBuZXcgU2h1ZmZsZShncmlkLCB7XG4gICAgICAgICAgaXRlbVNlbGVjdG9yOiAnLnByb2plY3RzLWNvbnRlbnRfaXRlbScsXG4gICAgICAgICAgZ3V0dGVyV2lkdGg6IDIwLFxuICAgICAgICAgIGNvbHVtbldpZHRoOiAodykgPT4ge1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gKHcgLyAzKSAtIDE1O1xuICAgICAgICAgICAgaWYgKHcgPCA0MDApIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcgPCA3NTApIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9ICh3IC8gMikgLSAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9qZWN0cy1jb250ZW50X2l0ZW0nKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBpdGVtLnN0eWxlLmhlaWdodCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucHJvamVjdC1maWx0ZXItYnV0dG9uJykuZm9yRWFjaCgoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIHNodWZmbGUuZmlsdGVyKGUudGFyZ2V0LmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IG9uUmVzaXplID0gKCkgPT4ge1xuICAgICAgICBhZGp1c3RQcm9qZWN0Q29udGFpbmVycygpO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgYWRqdXN0VmlkZW8oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgd2luZG93Lm9ucmVzaXplID0gb25SZXNpemU7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaG9tZS9zdGF0aWMvaG9tZS9qcy9ob21lLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.shuffle = factory());\n}(this, (function () { 'use strict';\n\n// Polyfill for creating CustomEvents on IE9/10/11\n\n// code pulled from:\n// https://github.com/d4tocchini/customevent-polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill\n\ntry {\n    var ce = new window.CustomEvent('test');\n    ce.preventDefault();\n    if (ce.defaultPrevented !== true) {\n        // IE has problems with .preventDefault() on custom events\n        // http://stackoverflow.com/questions/23349191\n        throw new Error('Could not prevent default');\n    }\n} catch(e) {\n  var CustomEvent$1 = function(event, params) {\n    var evt, origPrevent;\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    };\n\n    evt = document.createEvent(\"CustomEvent\");\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    origPrevent = evt.preventDefault;\n    evt.preventDefault = function () {\n      origPrevent.call(this);\n      try {\n        Object.defineProperty(this, 'defaultPrevented', {\n          get: function () {\n            return true;\n          }\n        });\n      } catch(e) {\n        this.defaultPrevented = true;\n      }\n    };\n    return evt;\n  };\n\n  CustomEvent$1.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent$1; // expose definition to window\n}\n\nvar proto = Element.prototype;\nvar vendor = proto.matches\n  || proto.matchesSelector\n  || proto.webkitMatchesSelector\n  || proto.mozMatchesSelector\n  || proto.msMatchesSelector\n  || proto.oMatchesSelector;\n\nvar index = match;\n\n/**\n * Match `el` to `selector`.\n *\n * @param {Element} el\n * @param {String} selector\n * @return {Boolean}\n * @api public\n */\n\nfunction match(el, selector) {\n  if (vendor) return vendor.call(el, selector);\n  var nodes = el.parentNode.querySelectorAll(selector);\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i] == el) return true;\n  }\n  return false;\n}\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\n\n\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar index$1 = createCommonjsModule(function (module) {\n'use strict';\n\n// there's 3 implementations written in increasing order of efficiency\n\n// 1 - no Set type is defined\nfunction uniqNoSet(arr) {\n\tvar ret = [];\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (ret.indexOf(arr[i]) === -1) {\n\t\t\tret.push(arr[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 2 - a simple Set type is defined\nfunction uniqSet(arr) {\n\tvar seen = new Set();\n\treturn arr.filter(function (el) {\n\t\tif (!seen.has(el)) {\n\t\t\tseen.add(el);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n\n// 3 - a standard Set type is defined and it has a forEach method\nfunction uniqSetWithForEach(arr) {\n\tvar ret = [];\n\n\t(new Set(arr)).forEach(function (el) {\n\t\tret.push(el);\n\t});\n\n\treturn ret;\n}\n\n// V8 currently has a broken implementation\n// https://github.com/joyent/node/issues/8449\nfunction doesForEachActuallyWork() {\n\tvar ret = false;\n\n\t(new Set([true])).forEach(function (el) {\n\t\tret = el;\n\t});\n\n\treturn ret === true;\n}\n\nif ('Set' in commonjsGlobal) {\n\tif (typeof Set.prototype.forEach === 'function' && doesForEachActuallyWork()) {\n\t\tmodule.exports = uniqSetWithForEach;\n\t} else {\n\t\tmodule.exports = uniqSet;\n\t}\n} else {\n\tmodule.exports = uniqNoSet;\n}\n});\n\nvar immutable = extend;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {};\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n\n    return target\n}\n\nvar index$2 = throttle;\n\n/**\n * Returns a new function that, when invoked, invokes `func` at most once per `wait` milliseconds.\n *\n * @param {Function} func Function to wrap.\n * @param {Number} wait Number of milliseconds that must elapse between `func` invocations.\n * @return {Function} A new function that wraps the `func` function passed in.\n */\n\nfunction throttle (func, wait) {\n  var ctx, args, rtn, timeoutID; // caching\n  var last = 0;\n\n  return function throttled () {\n    ctx = this;\n    args = arguments;\n    var delta = new Date() - last;\n    if (!timeoutID)\n      if (delta >= wait) call();\n      else timeoutID = setTimeout(call, wait - delta);\n    return rtn;\n  };\n\n  function call () {\n    timeoutID = 0;\n    last = +new Date();\n    rtn = func.apply(ctx, args);\n    ctx = null;\n    args = null;\n  }\n}\n\nvar index$3 = function parallel(fns, context, callback) {\n  if (!callback) {\n    if (typeof context === 'function') {\n      callback = context;\n      context = null;\n    } else {\n      callback = noop;\n    }\n  }\n\n  var pending = fns && fns.length;\n  if (!pending) return callback(null, []);\n\n  var finished = false;\n  var results = new Array(pending);\n\n  fns.forEach(context ? function (fn, i) {\n    fn.call(context, maybeDone(i));\n  } : function (fn, i) {\n    fn(maybeDone(i));\n  });\n\n  function maybeDone(i) {\n    return function (err, result) {\n      if (finished) return;\n\n      if (err) {\n        callback(err, results);\n        finished = true;\n        return\n      }\n\n      results[i] = result;\n\n      if (!--pending) callback(null, results);\n    }\n  }\n};\n\nfunction noop() {}\n\n/**\n * Always returns a numeric value, given a value. Logic from jQuery's `isNumeric`.\n * @param {*} value Possibly numeric value.\n * @return {number} `value` or zero if `value` isn't numeric.\n */\nfunction getNumber(value) {\n  return parseFloat(value) || 0;\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar Point = function () {\n\n  /**\n   * Represents a coordinate pair.\n   * @param {number} [x=0] X.\n   * @param {number} [y=0] Y.\n   */\n  function Point(x, y) {\n    classCallCheck(this, Point);\n\n    this.x = getNumber(x);\n    this.y = getNumber(y);\n  }\n\n  /**\n   * Whether two points are equal.\n   * @param {Point} a Point A.\n   * @param {Point} b Point B.\n   * @return {boolean}\n   */\n\n\n  createClass(Point, null, [{\n    key: 'equals',\n    value: function equals(a, b) {\n      return a.x === b.x && a.y === b.y;\n    }\n  }]);\n  return Point;\n}();\n\nvar Classes = {\n  BASE: 'shuffle',\n  SHUFFLE_ITEM: 'shuffle-item',\n  VISIBLE: 'shuffle-item--visible',\n  HIDDEN: 'shuffle-item--hidden'\n};\n\nvar id$1 = 0;\n\nvar ShuffleItem = function () {\n  function ShuffleItem(element) {\n    classCallCheck(this, ShuffleItem);\n\n    id$1 += 1;\n    this.id = id$1;\n    this.element = element;\n    this.isVisible = true;\n  }\n\n  createClass(ShuffleItem, [{\n    key: 'show',\n    value: function show() {\n      this.isVisible = true;\n      this.element.classList.remove(Classes.HIDDEN);\n      this.element.classList.add(Classes.VISIBLE);\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      this.isVisible = false;\n      this.element.classList.remove(Classes.VISIBLE);\n      this.element.classList.add(Classes.HIDDEN);\n    }\n  }, {\n    key: 'init',\n    value: function init() {\n      this.addClasses([Classes.SHUFFLE_ITEM, Classes.VISIBLE]);\n      this.applyCss(ShuffleItem.Css.INITIAL);\n      this.scale = ShuffleItem.Scale.VISIBLE;\n      this.point = new Point();\n    }\n  }, {\n    key: 'addClasses',\n    value: function addClasses(classes) {\n      var _this = this;\n\n      classes.forEach(function (className) {\n        _this.element.classList.add(className);\n      });\n    }\n  }, {\n    key: 'removeClasses',\n    value: function removeClasses(classes) {\n      var _this2 = this;\n\n      classes.forEach(function (className) {\n        _this2.element.classList.remove(className);\n      });\n    }\n  }, {\n    key: 'applyCss',\n    value: function applyCss(obj) {\n      var _this3 = this;\n\n      Object.keys(obj).forEach(function (key) {\n        _this3.element.style[key] = obj[key];\n      });\n    }\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.removeClasses([Classes.HIDDEN, Classes.VISIBLE, Classes.SHUFFLE_ITEM]);\n\n      this.element.removeAttribute('style');\n      this.element = null;\n    }\n  }]);\n  return ShuffleItem;\n}();\n\nShuffleItem.Css = {\n  INITIAL: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    visibility: 'visible',\n    'will-change': 'transform'\n  },\n  VISIBLE: {\n    before: {\n      opacity: 1,\n      visibility: 'visible'\n    },\n    after: {}\n  },\n  HIDDEN: {\n    before: {\n      opacity: 0\n    },\n    after: {\n      visibility: 'hidden'\n    }\n  }\n};\n\nShuffleItem.Scale = {\n  VISIBLE: 1,\n  HIDDEN: 0.001\n};\n\nvar element = document.body || document.documentElement;\nvar e$1 = document.createElement('div');\ne$1.style.cssText = 'width:10px;padding:2px;box-sizing:border-box;';\nelement.appendChild(e$1);\n\nvar width = window.getComputedStyle(e$1, null).width;\nvar ret = width === '10px';\n\nelement.removeChild(e$1);\n\n/**\n * Retrieve the computed style for an element, parsed as a float.\n * @param {Element} element Element to get style for.\n * @param {string} style Style property.\n * @param {CSSStyleDeclaration} [styles] Optionally include clean styles to\n *     use instead of asking for them again.\n * @return {number} The parsed computed value or zero if that fails because IE\n *     will return 'auto' when the element doesn't have margins instead of\n *     the computed style.\n */\nfunction getNumberStyle(element, style) {\n  var styles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window.getComputedStyle(element, null);\n\n  var value = getNumber(styles[style]);\n\n  // Support IE<=11 and W3C spec.\n  if (!ret && style === 'width') {\n    value += getNumber(styles.paddingLeft) + getNumber(styles.paddingRight) + getNumber(styles.borderLeftWidth) + getNumber(styles.borderRightWidth);\n  } else if (!ret && style === 'height') {\n    value += getNumber(styles.paddingTop) + getNumber(styles.paddingBottom) + getNumber(styles.borderTopWidth) + getNumber(styles.borderBottomWidth);\n  }\n\n  return value;\n}\n\n/**\n * Fisher-Yates shuffle.\n * http://stackoverflow.com/a/962890/373422\n * https://bost.ocks.org/mike/shuffle/\n * @param {Array} array Array to shuffle.\n * @return {Array} Randomly sorted array.\n */\nfunction randomize(array) {\n  var n = array.length;\n\n  while (n) {\n    n -= 1;\n    var i = Math.floor(Math.random() * (n + 1));\n    var temp = array[i];\n    array[i] = array[n];\n    array[n] = temp;\n  }\n\n  return array;\n}\n\nvar defaults$1 = {\n  // Use array.reverse() to reverse the results\n  reverse: false,\n\n  // Sorting function\n  by: null,\n\n  // If true, this will skip the sorting and return a randomized order in the array\n  randomize: false,\n\n  // Determines which property of each item in the array is passed to the\n  // sorting method.\n  key: 'element'\n};\n\n// You can return `undefined` from the `by` function to revert to DOM order.\nfunction sorter(arr, options) {\n  var opts = immutable(defaults$1, options);\n  var original = [].slice.call(arr);\n  var revert = false;\n\n  if (!arr.length) {\n    return [];\n  }\n\n  if (opts.randomize) {\n    return randomize(arr);\n  }\n\n  // Sort the elements by the opts.by function.\n  // If we don't have opts.by, default to DOM order\n  if (typeof opts.by === 'function') {\n    arr.sort(function (a, b) {\n      // Exit early if we already know we want to revert\n      if (revert) {\n        return 0;\n      }\n\n      var valA = opts.by(a[opts.key]);\n      var valB = opts.by(b[opts.key]);\n\n      // If both values are undefined, use the DOM order\n      if (valA === undefined && valB === undefined) {\n        revert = true;\n        return 0;\n      }\n\n      if (valA < valB || valA === 'sortFirst' || valB === 'sortLast') {\n        return -1;\n      }\n\n      if (valA > valB || valA === 'sortLast' || valB === 'sortFirst') {\n        return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  // Revert to the original array if necessary\n  if (revert) {\n    return original;\n  }\n\n  if (opts.reverse) {\n    arr.reverse();\n  }\n\n  return arr;\n}\n\nvar transitions = {};\nvar eventName = 'transitionend';\nvar count = 0;\n\nfunction uniqueId() {\n  count += 1;\n  return eventName + count;\n}\n\nfunction cancelTransitionEnd(id) {\n  if (transitions[id]) {\n    transitions[id].element.removeEventListener(eventName, transitions[id].listener);\n    transitions[id] = null;\n    return true;\n  }\n\n  return false;\n}\n\nfunction onTransitionEnd(element, callback) {\n  var id = uniqueId();\n  var listener = function listener(evt) {\n    if (evt.currentTarget === evt.target) {\n      cancelTransitionEnd(id);\n      callback(evt);\n    }\n  };\n\n  element.addEventListener(eventName, listener);\n\n  transitions[id] = { element: element, listener: listener };\n\n  return id;\n}\n\nfunction arrayMax(array) {\n  return Math.max.apply(Math, array); // eslint-disable-line prefer-spread\n}\n\nfunction arrayMin(array) {\n  return Math.min.apply(Math, array); // eslint-disable-line prefer-spread\n}\n\n/**\n * Determine the number of columns an items spans.\n * @param {number} itemWidth Width of the item.\n * @param {number} columnWidth Width of the column (includes gutter).\n * @param {number} columns Total number of columns\n * @param {number} threshold A buffer value for the size of the column to fit.\n * @return {number}\n */\nfunction getColumnSpan(itemWidth, columnWidth, columns, threshold) {\n  var columnSpan = itemWidth / columnWidth;\n\n  // If the difference between the rounded column span number and the\n  // calculated column span number is really small, round the number to\n  // make it fit.\n  if (Math.abs(Math.round(columnSpan) - columnSpan) < threshold) {\n    // e.g. columnSpan = 4.0089945390298745\n    columnSpan = Math.round(columnSpan);\n  }\n\n  // Ensure the column span is not more than the amount of columns in the whole layout.\n  return Math.min(Math.ceil(columnSpan), columns);\n}\n\n/**\n * Retrieves the column set to use for placement.\n * @param {number} columnSpan The number of columns this current item spans.\n * @param {number} columns The total columns in the grid.\n * @return {Array.<number>} An array of numbers represeting the column set.\n */\nfunction getAvailablePositions(positions, columnSpan, columns) {\n  // The item spans only one column.\n  if (columnSpan === 1) {\n    return positions;\n  }\n\n  // The item spans more than one column, figure out how many different\n  // places it could fit horizontally.\n  // The group count is the number of places within the positions this block\n  // could fit, ignoring the current positions of items.\n  // Imagine a 2 column brick as the second item in a 4 column grid with\n  // 10px height each. Find the places it would fit:\n  // [20, 10, 10, 0]\n  //  |   |   |\n  //  *   *   *\n  //\n  // Then take the places which fit and get the bigger of the two:\n  // max([20, 10]), max([10, 10]), max([10, 0]) = [20, 10, 0]\n  //\n  // Next, find the first smallest number (the short column).\n  // [20, 10, 0]\n  //          |\n  //          *\n  //\n  // And that's where it should be placed!\n  //\n  // Another example where the second column's item extends past the first:\n  // [10, 20, 10, 0] => [20, 20, 10] => 10\n  var available = [];\n\n  // For how many possible positions for this item there are.\n  for (var i = 0; i <= columns - columnSpan; i++) {\n    // Find the bigger value for each place it could fit.\n    available.push(arrayMax(positions.slice(i, i + columnSpan)));\n  }\n\n  return available;\n}\n\n/**\n * Find index of short column, the first from the left where this item will go.\n *\n * @param {Array.<number>} positions The array to search for the smallest number.\n * @param {number} buffer Optional buffer which is very useful when the height\n *     is a percentage of the width.\n * @return {number} Index of the short column.\n */\nfunction getShortColumn(positions, buffer) {\n  var minPosition = arrayMin(positions);\n  for (var i = 0, len = positions.length; i < len; i++) {\n    if (positions[i] >= minPosition - buffer && positions[i] <= minPosition + buffer) {\n      return i;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Determine the location of the next item, based on its size.\n * @param {Object} itemSize Object with width and height.\n * @param {Array.<number>} positions Positions of the other current items.\n * @param {number} gridSize The column width or row height.\n * @param {number} total The total number of columns or rows.\n * @param {number} threshold Buffer value for the column to fit.\n * @param {number} buffer Vertical buffer for the height of items.\n * @return {Point}\n */\nfunction getItemPosition(_ref) {\n  var itemSize = _ref.itemSize,\n      positions = _ref.positions,\n      gridSize = _ref.gridSize,\n      total = _ref.total,\n      threshold = _ref.threshold,\n      buffer = _ref.buffer;\n\n  var span = getColumnSpan(itemSize.width, gridSize, total, threshold);\n  var setY = getAvailablePositions(positions, span, total);\n  var shortColumnIndex = getShortColumn(setY, buffer);\n\n  // Position the item\n  var point = new Point(Math.round(gridSize * shortColumnIndex), Math.round(setY[shortColumnIndex]));\n\n  // Update the columns array with the new values for each column.\n  // e.g. before the update the columns could be [250, 0, 0, 0] for an item\n  // which spans 2 columns. After it would be [250, itemHeight, itemHeight, 0].\n  var setHeight = setY[shortColumnIndex] + itemSize.height;\n  for (var i = 0; i < span; i++) {\n    positions[shortColumnIndex + i] = setHeight;\n  }\n\n  return point;\n}\n\nfunction toArray$$1(arrayLike) {\n  return Array.prototype.slice.call(arrayLike);\n}\n\nfunction arrayIncludes(array, obj) {\n  return array.indexOf(obj) > -1;\n}\n\n// Used for unique instance variables\nvar id = 0;\n\nvar Shuffle = function () {\n\n  /**\n   * Categorize, sort, and filter a responsive grid of items.\n   *\n   * @param {Element} element An element which is the parent container for the grid items.\n   * @param {Object} [options=Shuffle.options] Options object.\n   * @constructor\n   */\n  function Shuffle(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Shuffle);\n\n    this.options = immutable(Shuffle.options, options);\n\n    this.useSizer = false;\n    this.lastSort = {};\n    this.group = Shuffle.ALL_ITEMS;\n    this.lastFilter = Shuffle.ALL_ITEMS;\n    this.isEnabled = true;\n    this.isDestroyed = false;\n    this.isInitialized = false;\n    this._transitions = [];\n    this.isTransitioning = false;\n    this._queue = [];\n\n    var el = this._getElementOption(element);\n\n    if (!el) {\n      throw new TypeError('Shuffle needs to be initialized with an element.');\n    }\n\n    this.element = el;\n    this.id = 'shuffle_' + id;\n    id += 1;\n\n    this._init();\n    this.isInitialized = true;\n  }\n\n  createClass(Shuffle, [{\n    key: '_init',\n    value: function _init() {\n      this.items = this._getItems();\n\n      this.options.sizer = this._getElementOption(this.options.sizer);\n\n      if (this.options.sizer) {\n        this.useSizer = true;\n      }\n\n      // Add class and invalidate styles\n      this.element.classList.add(Shuffle.Classes.BASE);\n\n      // Set initial css for each item\n      this._initItems();\n\n      // Bind resize events\n      this._onResize = this._getResizeFunction();\n      window.addEventListener('resize', this._onResize);\n\n      // Get container css all in one request. Causes reflow\n      var containerCss = window.getComputedStyle(this.element, null);\n      var containerWidth = Shuffle.getSize(this.element).width;\n\n      // Add styles to the container if it doesn't have them.\n      this._validateStyles(containerCss);\n\n      // We already got the container's width above, no need to cause another\n      // reflow getting it again... Calculate the number of columns there will be\n      this._setColumns(containerWidth);\n\n      // Kick off!\n      this.filter(this.options.group, this.options.initialSort);\n\n      // The shuffle items haven't had transitions set on them yet so the user\n      // doesn't see the first layout. Set them now that the first layout is done.\n      // First, however, a synchronous layout must be caused for the previous\n      // styles to be applied without transitions.\n      this.element.offsetWidth; // eslint-disable-line no-unused-expressions\n      this._setTransitions();\n      this.element.style.transition = 'height ' + this.options.speed + 'ms ' + this.options.easing;\n    }\n\n    /**\n     * Returns a throttled and proxied function for the resize handler.\n     * @return {Function}\n     * @private\n     */\n\n  }, {\n    key: '_getResizeFunction',\n    value: function _getResizeFunction() {\n      var resizeFunction = this._handleResize.bind(this);\n      return this.options.throttle ? this.options.throttle(resizeFunction, this.options.throttleTime) : resizeFunction;\n    }\n\n    /**\n     * Retrieve an element from an option.\n     * @param {string|jQuery|Element} option The option to check.\n     * @return {?Element} The plain element or null.\n     * @private\n     */\n\n  }, {\n    key: '_getElementOption',\n    value: function _getElementOption(option) {\n      // If column width is a string, treat is as a selector and search for the\n      // sizer element within the outermost container\n      if (typeof option === 'string') {\n        return this.element.querySelector(option);\n\n        // Check for an element\n      } else if (option && option.nodeType && option.nodeType === 1) {\n        return option;\n\n        // Check for jQuery object\n      } else if (option && option.jquery) {\n        return option[0];\n      }\n\n      return null;\n    }\n\n    /**\n     * Ensures the shuffle container has the css styles it needs applied to it.\n     * @param {Object} styles Key value pairs for position and overflow.\n     * @private\n     */\n\n  }, {\n    key: '_validateStyles',\n    value: function _validateStyles(styles) {\n      // Position cannot be static.\n      if (styles.position === 'static') {\n        this.element.style.position = 'relative';\n      }\n\n      // Overflow has to be hidden.\n      if (styles.overflow !== 'hidden') {\n        this.element.style.overflow = 'hidden';\n      }\n    }\n\n    /**\n     * Filter the elements by a category.\n     * @param {string} [category] Category to filter by. If it's given, the last\n     *     category will be used to filter the items.\n     * @param {Array} [collection] Optionally filter a collection. Defaults to\n     *     all the items.\n     * @return {!{visible: Array, hidden: Array}}\n     * @private\n     */\n\n  }, {\n    key: '_filter',\n    value: function _filter() {\n      var category = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.lastFilter;\n      var collection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.items;\n\n      var set$$1 = this._getFilteredSets(category, collection);\n\n      // Individually add/remove hidden/visible classes\n      this._toggleFilterClasses(set$$1);\n\n      // Save the last filter in case elements are appended.\n      this.lastFilter = category;\n\n      // This is saved mainly because providing a filter function (like searching)\n      // will overwrite the `lastFilter` property every time its called.\n      if (typeof category === 'string') {\n        this.group = category;\n      }\n\n      return set$$1;\n    }\n\n    /**\n     * Returns an object containing the visible and hidden elements.\n     * @param {string|Function} category Category or function to filter by.\n     * @param {Array.<Element>} items A collection of items to filter.\n     * @return {!{visible: Array, hidden: Array}}\n     * @private\n     */\n\n  }, {\n    key: '_getFilteredSets',\n    value: function _getFilteredSets(category, items) {\n      var _this = this;\n\n      var visible = [];\n      var hidden = [];\n\n      // category === 'all', add visible class to everything\n      if (category === Shuffle.ALL_ITEMS) {\n        visible = items;\n\n        // Loop through each item and use provided function to determine\n        // whether to hide it or not.\n      } else {\n        items.forEach(function (item) {\n          if (_this._doesPassFilter(category, item.element)) {\n            visible.push(item);\n          } else {\n            hidden.push(item);\n          }\n        });\n      }\n\n      return {\n        visible: visible,\n        hidden: hidden\n      };\n    }\n\n    /**\n     * Test an item to see if it passes a category.\n     * @param {string|Function} category Category or function to filter by.\n     * @param {Element} element An element to test.\n     * @return {boolean} Whether it passes the category/filter.\n     * @private\n     */\n\n  }, {\n    key: '_doesPassFilter',\n    value: function _doesPassFilter(category, element) {\n      if (typeof category === 'function') {\n        return category.call(element, element, this);\n      }\n\n      // Check each element's data-groups attribute against the given category.\n      var attr = element.getAttribute('data-' + Shuffle.FILTER_ATTRIBUTE_KEY);\n      var keys = this.options.delimeter ? attr.split(this.options.delimeter) : JSON.parse(attr);\n\n      function testCategory(category) {\n        return arrayIncludes(keys, category);\n      }\n\n      if (Array.isArray(category)) {\n        if (this.options.filterMode === Shuffle.FilterMode.ANY) {\n          return category.some(testCategory);\n        }\n        return category.every(testCategory);\n      }\n\n      return arrayIncludes(keys, category);\n    }\n\n    /**\n     * Toggles the visible and hidden class names.\n     * @param {{visible, hidden}} Object with visible and hidden arrays.\n     * @private\n     */\n\n  }, {\n    key: '_toggleFilterClasses',\n    value: function _toggleFilterClasses(_ref) {\n      var visible = _ref.visible,\n          hidden = _ref.hidden;\n\n      visible.forEach(function (item) {\n        item.show();\n      });\n\n      hidden.forEach(function (item) {\n        item.hide();\n      });\n    }\n\n    /**\n     * Set the initial css for each item\n     * @param {Array.<ShuffleItem>} [items] Optionally specifiy at set to initialize.\n     * @private\n     */\n\n  }, {\n    key: '_initItems',\n    value: function _initItems() {\n      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items;\n\n      items.forEach(function (item) {\n        item.init();\n      });\n    }\n\n    /**\n     * Remove element reference and styles.\n     * @private\n     */\n\n  }, {\n    key: '_disposeItems',\n    value: function _disposeItems() {\n      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items;\n\n      items.forEach(function (item) {\n        item.dispose();\n      });\n    }\n\n    /**\n     * Updates the visible item count.\n     * @private\n     */\n\n  }, {\n    key: '_updateItemCount',\n    value: function _updateItemCount() {\n      this.visibleItems = this._getFilteredItems().length;\n    }\n\n    /**\n     * Sets css transform transition on a group of elements. This is not executed\n     * at the same time as `item.init` so that transitions don't occur upon\n     * initialization of Shuffle.\n     * @param {Array.<ShuffleItem>} items Shuffle items to set transitions on.\n     * @private\n     */\n\n  }, {\n    key: '_setTransitions',\n    value: function _setTransitions() {\n      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items;\n\n      var speed = this.options.speed;\n      var easing = this.options.easing;\n\n      var str = this.options.useTransforms ? 'transform ' + speed + 'ms ' + easing + ', opacity ' + speed + 'ms ' + easing : 'top ' + speed + 'ms ' + easing + ', left ' + speed + 'ms ' + easing + ', opacity ' + speed + 'ms ' + easing;\n\n      items.forEach(function (item) {\n        item.element.style.transition = str;\n      });\n    }\n  }, {\n    key: '_getItems',\n    value: function _getItems() {\n      var _this2 = this;\n\n      return toArray$$1(this.element.children).filter(function (el) {\n        return index(el, _this2.options.itemSelector);\n      }).map(function (el) {\n        return new ShuffleItem(el);\n      });\n    }\n\n    /**\n     * When new elements are added to the shuffle container, update the array of\n     * items because that is the order `_layout` calls them.\n     */\n\n  }, {\n    key: '_updateItemsOrder',\n    value: function _updateItemsOrder() {\n      var children = this.element.children;\n      this.items = sorter(this.items, {\n        by: function by(element) {\n          return Array.prototype.indexOf.call(children, element);\n        }\n      });\n    }\n  }, {\n    key: '_getFilteredItems',\n    value: function _getFilteredItems() {\n      return this.items.filter(function (item) {\n        return item.isVisible;\n      });\n    }\n  }, {\n    key: '_getConcealedItems',\n    value: function _getConcealedItems() {\n      return this.items.filter(function (item) {\n        return !item.isVisible;\n      });\n    }\n\n    /**\n     * Returns the column size, based on column width and sizer options.\n     * @param {number} containerWidth Size of the parent container.\n     * @param {number} gutterSize Size of the gutters.\n     * @return {number}\n     * @private\n     */\n\n  }, {\n    key: '_getColumnSize',\n    value: function _getColumnSize(containerWidth, gutterSize) {\n      var size = void 0;\n\n      // If the columnWidth property is a function, then the grid is fluid\n      if (typeof this.options.columnWidth === 'function') {\n        size = this.options.columnWidth(containerWidth);\n\n        // columnWidth option isn't a function, are they using a sizing element?\n      } else if (this.useSizer) {\n        size = Shuffle.getSize(this.options.sizer).width;\n\n        // if not, how about the explicitly set option?\n      } else if (this.options.columnWidth) {\n        size = this.options.columnWidth;\n\n        // or use the size of the first item\n      } else if (this.items.length > 0) {\n        size = Shuffle.getSize(this.items[0].element, true).width;\n\n        // if there's no items, use size of container\n      } else {\n        size = containerWidth;\n      }\n\n      // Don't let them set a column width of zero.\n      if (size === 0) {\n        size = containerWidth;\n      }\n\n      return size + gutterSize;\n    }\n\n    /**\n     * Returns the gutter size, based on gutter width and sizer options.\n     * @param {number} containerWidth Size of the parent container.\n     * @return {number}\n     * @private\n     */\n\n  }, {\n    key: '_getGutterSize',\n    value: function _getGutterSize(containerWidth) {\n      var size = void 0;\n      if (typeof this.options.gutterWidth === 'function') {\n        size = this.options.gutterWidth(containerWidth);\n      } else if (this.useSizer) {\n        size = getNumberStyle(this.options.sizer, 'marginLeft');\n      } else {\n        size = this.options.gutterWidth;\n      }\n\n      return size;\n    }\n\n    /**\n     * Calculate the number of columns to be used. Gets css if using sizer element.\n     * @param {number} [containerWidth] Optionally specify a container width if\n     *    it's already available.\n     */\n\n  }, {\n    key: '_setColumns',\n    value: function _setColumns() {\n      var containerWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Shuffle.getSize(this.element).width;\n\n      var gutter = this._getGutterSize(containerWidth);\n      var columnWidth = this._getColumnSize(containerWidth, gutter);\n      var calculatedColumns = (containerWidth + gutter) / columnWidth;\n\n      // Widths given from getStyles are not precise enough...\n      if (Math.abs(Math.round(calculatedColumns) - calculatedColumns) < this.options.columnThreshold) {\n        // e.g. calculatedColumns = 11.998876\n        calculatedColumns = Math.round(calculatedColumns);\n      }\n\n      this.cols = Math.max(Math.floor(calculatedColumns), 1);\n      this.containerWidth = containerWidth;\n      this.colWidth = columnWidth;\n    }\n\n    /**\n     * Adjust the height of the grid\n     */\n\n  }, {\n    key: '_setContainerSize',\n    value: function _setContainerSize() {\n      this.element.style.height = this._getContainerSize() + 'px';\n    }\n\n    /**\n     * Based on the column heights, it returns the biggest one.\n     * @return {number}\n     * @private\n     */\n\n  }, {\n    key: '_getContainerSize',\n    value: function _getContainerSize() {\n      return arrayMax(this.positions);\n    }\n\n    /**\n     * Get the clamped stagger amount.\n     * @param {number} index Index of the item to be staggered.\n     * @return {number}\n     */\n\n  }, {\n    key: '_getStaggerAmount',\n    value: function _getStaggerAmount(index$$1) {\n      return Math.min(index$$1 * this.options.staggerAmount, this.options.staggerAmountMax);\n    }\n\n    /**\n     * @return {boolean} Whether the event was prevented or not.\n     */\n\n  }, {\n    key: '_dispatch',\n    value: function _dispatch(name) {\n      var details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.isDestroyed) {\n        return false;\n      }\n\n      details.shuffle = this;\n      return !this.element.dispatchEvent(new CustomEvent(name, {\n        bubbles: true,\n        cancelable: false,\n        detail: details\n      }));\n    }\n\n    /**\n     * Zeros out the y columns array, which is used to determine item placement.\n     * @private\n     */\n\n  }, {\n    key: '_resetCols',\n    value: function _resetCols() {\n      var i = this.cols;\n      this.positions = [];\n      while (i) {\n        i -= 1;\n        this.positions.push(0);\n      }\n    }\n\n    /**\n     * Loops through each item that should be shown and calculates the x, y position.\n     * @param {Array.<ShuffleItem>} items Array of items that will be shown/layed\n     *     out in order in their array.\n     */\n\n  }, {\n    key: '_layout',\n    value: function _layout(items) {\n      var _this3 = this;\n\n      var count = 0;\n      items.forEach(function (item) {\n        var currPos = item.point;\n        var currScale = item.scale;\n        var itemSize = Shuffle.getSize(item.element, true);\n        var pos = _this3._getItemPosition(itemSize);\n\n        function callback() {\n          item.element.style.transitionDelay = '';\n          item.applyCss(ShuffleItem.Css.VISIBLE.after);\n        }\n\n        // If the item will not change its position, do not add it to the render\n        // queue. Transitions don't fire when setting a property to the same value.\n        if (Point.equals(currPos, pos) && currScale === ShuffleItem.Scale.VISIBLE) {\n          item.applyCss(ShuffleItem.Css.VISIBLE.before);\n          callback();\n          return;\n        }\n\n        item.point = pos;\n        item.scale = ShuffleItem.Scale.VISIBLE;\n\n        // Use xtend here to clone the object so that the `before` object isn't\n        // modified when the transition delay is added.\n        var styles = immutable(ShuffleItem.Css.VISIBLE.before);\n        styles.transitionDelay = _this3._getStaggerAmount(count) + 'ms';\n\n        _this3._queue.push({\n          item: item,\n          styles: styles,\n          callback: callback\n        });\n\n        count += 1;\n      });\n    }\n\n    /**\n     * Determine the location of the next item, based on its size.\n     * @param {{width: number, height: number}} itemSize Object with width and height.\n     * @return {Point}\n     * @private\n     */\n\n  }, {\n    key: '_getItemPosition',\n    value: function _getItemPosition(itemSize) {\n      return getItemPosition({\n        itemSize: itemSize,\n        positions: this.positions,\n        gridSize: this.colWidth,\n        total: this.cols,\n        threshold: this.options.columnThreshold,\n        buffer: this.options.buffer\n      });\n    }\n\n    /**\n     * Hides the elements that don't match our filter.\n     * @param {Array.<ShuffleItem>} collection Collection to shrink.\n     * @private\n     */\n\n  }, {\n    key: '_shrink',\n    value: function _shrink() {\n      var _this4 = this;\n\n      var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._getConcealedItems();\n\n      var count = 0;\n      collection.forEach(function (item) {\n        function callback() {\n          item.applyCss(ShuffleItem.Css.HIDDEN.after);\n        }\n\n        // Continuing would add a transitionend event listener to the element, but\n        // that listener would not execute because the transform and opacity would\n        // stay the same.\n        // The callback is executed here because it is not guaranteed to be called\n        // after the transitionend event because the transitionend could be\n        // canceled if another animation starts.\n        if (item.scale === ShuffleItem.Scale.HIDDEN) {\n          item.applyCss(ShuffleItem.Css.HIDDEN.before);\n          callback();\n          return;\n        }\n\n        item.scale = ShuffleItem.Scale.HIDDEN;\n\n        var styles = immutable(ShuffleItem.Css.HIDDEN.before);\n        styles.transitionDelay = _this4._getStaggerAmount(count) + 'ms';\n\n        _this4._queue.push({\n          item: item,\n          styles: styles,\n          callback: callback\n        });\n\n        count += 1;\n      });\n    }\n\n    /**\n     * Resize handler.\n     * @private\n     */\n\n  }, {\n    key: '_handleResize',\n    value: function _handleResize() {\n      // If shuffle is disabled, destroyed, don't do anything\n      if (!this.isEnabled || this.isDestroyed) {\n        return;\n      }\n\n      // Will need to check height in the future if it's layed out horizontaly\n      var containerWidth = Shuffle.getSize(this.element).width;\n\n      // containerWidth hasn't changed, don't do anything\n      if (containerWidth === this.containerWidth) {\n        return;\n      }\n\n      this.update();\n    }\n\n    /**\n     * Returns styles which will be applied to the an item for a transition.\n     * @param {Object} obj Transition options.\n     * @return {!Object} Transforms for transitions, left/top for animate.\n     * @private\n     */\n\n  }, {\n    key: '_getStylesForTransition',\n    value: function _getStylesForTransition(_ref2) {\n      var item = _ref2.item,\n          styles = _ref2.styles;\n\n      if (!styles.transitionDelay) {\n        styles.transitionDelay = '0ms';\n      }\n\n      var x = item.point.x;\n      var y = item.point.y;\n\n      if (this.options.useTransforms) {\n        styles.transform = 'translate(' + x + 'px, ' + y + 'px) scale(' + item.scale + ')';\n      } else {\n        styles.left = x + 'px';\n        styles.top = y + 'px';\n      }\n\n      return styles;\n    }\n\n    /**\n     * Listen for the transition end on an element and execute the itemCallback\n     * when it finishes.\n     * @param {Element} element Element to listen on.\n     * @param {Function} itemCallback Callback for the item.\n     * @param {Function} done Callback to notify `parallel` that this one is done.\n     */\n\n  }, {\n    key: '_whenTransitionDone',\n    value: function _whenTransitionDone(element, itemCallback, done) {\n      var id = onTransitionEnd(element, function (evt) {\n        itemCallback();\n        done(null, evt);\n      });\n\n      this._transitions.push(id);\n    }\n\n    /**\n     * Return a function which will set CSS styles and call the `done` function\n     * when (if) the transition finishes.\n     * @param {Object} opts Transition object.\n     * @return {Function} A function to be called with a `done` function.\n     */\n\n  }, {\n    key: '_getTransitionFunction',\n    value: function _getTransitionFunction(opts) {\n      var _this5 = this;\n\n      return function (done) {\n        opts.item.applyCss(_this5._getStylesForTransition(opts));\n        _this5._whenTransitionDone(opts.item.element, opts.callback, done);\n      };\n    }\n\n    /**\n     * Execute the styles gathered in the style queue. This applies styles to elements,\n     * triggering transitions.\n     * @private\n     */\n\n  }, {\n    key: '_processQueue',\n    value: function _processQueue() {\n      if (this.isTransitioning) {\n        this._cancelMovement();\n      }\n\n      var hasSpeed = this.options.speed > 0;\n      var hasQueue = this._queue.length > 0;\n\n      if (hasQueue && hasSpeed && this.isInitialized) {\n        this._startTransitions(this._queue);\n      } else if (hasQueue) {\n        this._styleImmediately(this._queue);\n        this._dispatchLayout();\n\n        // A call to layout happened, but none of the newly visible items will\n        // change position or the transition duration is zero, which will not trigger\n        // the transitionend event.\n      } else {\n        this._dispatchLayout();\n      }\n\n      // Remove everything in the style queue\n      this._queue.length = 0;\n    }\n\n    /**\n     * Wait for each transition to finish, the emit the layout event.\n     * @param {Array.<Object>} transitions Array of transition objects.\n     */\n\n  }, {\n    key: '_startTransitions',\n    value: function _startTransitions(transitions) {\n      var _this6 = this;\n\n      // Set flag that shuffle is currently in motion.\n      this.isTransitioning = true;\n\n      // Create an array of functions to be called.\n      var callbacks = transitions.map(function (obj) {\n        return _this6._getTransitionFunction(obj);\n      });\n\n      index$3(callbacks, this._movementFinished.bind(this));\n    }\n  }, {\n    key: '_cancelMovement',\n    value: function _cancelMovement() {\n      // Remove the transition end event for each listener.\n      this._transitions.forEach(cancelTransitionEnd);\n\n      // Reset the array.\n      this._transitions.length = 0;\n\n      // Show it's no longer active.\n      this.isTransitioning = false;\n    }\n\n    /**\n     * Apply styles without a transition.\n     * @param {Array.<Object>} objects Array of transition objects.\n     * @private\n     */\n\n  }, {\n    key: '_styleImmediately',\n    value: function _styleImmediately(objects) {\n      var _this7 = this;\n\n      if (objects.length) {\n        var elements = objects.map(function (obj) {\n          return obj.item.element;\n        });\n\n        Shuffle._skipTransitions(elements, function () {\n          objects.forEach(function (obj) {\n            obj.item.applyCss(_this7._getStylesForTransition(obj));\n            obj.callback();\n          });\n        });\n      }\n    }\n  }, {\n    key: '_movementFinished',\n    value: function _movementFinished() {\n      this._transitions.length = 0;\n      this.isTransitioning = false;\n      this._dispatchLayout();\n    }\n  }, {\n    key: '_dispatchLayout',\n    value: function _dispatchLayout() {\n      this._dispatch(Shuffle.EventType.LAYOUT);\n    }\n\n    /**\n     * The magic. This is what makes the plugin 'shuffle'\n     * @param {string|Function|Array.<string>} [category] Category to filter by.\n     *     Can be a function, string, or array of strings.\n     * @param {Object} [sortObj] A sort object which can sort the visible set\n     */\n\n  }, {\n    key: 'filter',\n    value: function filter(category, sortObj) {\n      if (!this.isEnabled) {\n        return;\n      }\n\n      if (!category || category && category.length === 0) {\n        category = Shuffle.ALL_ITEMS; // eslint-disable-line no-param-reassign\n      }\n\n      this._filter(category);\n\n      // Shrink each hidden item\n      this._shrink();\n\n      // How many visible elements?\n      this._updateItemCount();\n\n      // Update transforms on visible elements so they will animate to their new positions.\n      this.sort(sortObj);\n    }\n\n    /**\n     * Gets the visible elements, sorts them, and passes them to layout.\n     * @param {Object} opts the options object for the sorted plugin\n     */\n\n  }, {\n    key: 'sort',\n    value: function sort() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.lastSort;\n\n      if (!this.isEnabled) {\n        return;\n      }\n\n      this._resetCols();\n\n      var items = this._getFilteredItems();\n      items = sorter(items, opts);\n\n      this._layout(items);\n\n      // `_layout` always happens after `_shrink`, so it's safe to process the style\n      // queue here with styles from the shrink method.\n      this._processQueue();\n\n      // Adjust the height of the container.\n      this._setContainerSize();\n\n      this.lastSort = opts;\n    }\n\n    /**\n     * Reposition everything.\n     * @param {boolean} isOnlyLayout If true, column and gutter widths won't be\n     *     recalculated.\n     */\n\n  }, {\n    key: 'update',\n    value: function update(isOnlyLayout) {\n      if (this.isEnabled) {\n        if (!isOnlyLayout) {\n          // Get updated colCount\n          this._setColumns();\n        }\n\n        // Layout items\n        this.sort();\n      }\n    }\n\n    /**\n     * Use this instead of `update()` if you don't need the columns and gutters updated\n     * Maybe an image inside `shuffle` loaded (and now has a height), which means calculations\n     * could be off.\n     */\n\n  }, {\n    key: 'layout',\n    value: function layout() {\n      this.update(true);\n    }\n\n    /**\n     * New items have been appended to shuffle. Mix them in with the current\n     * filter or sort status.\n     * @param {Array.<Element>} newItems Collection of new items.\n     */\n\n  }, {\n    key: 'add',\n    value: function add(newItems) {\n      var items = index$1(newItems).map(function (el) {\n        return new ShuffleItem(el);\n      });\n\n      // Add classes and set initial positions.\n      this._initItems(items);\n\n      // Add transition to each item.\n      this._setTransitions(items);\n\n      // Update the list of items.\n      this.items = this.items.concat(items);\n      this._updateItemsOrder();\n      this.filter(this.lastFilter);\n    }\n\n    /**\n     * Disables shuffle from updating dimensions and layout on resize\n     */\n\n  }, {\n    key: 'disable',\n    value: function disable() {\n      this.isEnabled = false;\n    }\n\n    /**\n     * Enables shuffle again\n     * @param {boolean} [isUpdateLayout=true] if undefined, shuffle will update columns and gutters\n     */\n\n  }, {\n    key: 'enable',\n    value: function enable(isUpdateLayout) {\n      this.isEnabled = true;\n      if (isUpdateLayout !== false) {\n        this.update();\n      }\n    }\n\n    /**\n     * Remove 1 or more shuffle items\n     * @param {Array.<Element>} elements An array containing one or more\n     *     elements in shuffle\n     * @return {Shuffle} The shuffle object\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(elements) {\n      var _this8 = this;\n\n      if (!elements.length) {\n        return;\n      }\n\n      var collection = index$1(elements);\n\n      var oldItems = collection.map(function (element) {\n        return _this8.getItemByElement(element);\n      }).filter(function (item) {\n        return !!item;\n      });\n\n      var handleLayout = function handleLayout() {\n        _this8.element.removeEventListener(Shuffle.EventType.LAYOUT, handleLayout);\n        _this8._disposeItems(oldItems);\n\n        // Remove the collection in the callback\n        collection.forEach(function (element) {\n          element.parentNode.removeChild(element);\n        });\n\n        _this8._dispatch(Shuffle.EventType.REMOVED, { collection: collection });\n      };\n\n      // Hide collection first.\n      this._toggleFilterClasses({\n        visible: [],\n        hidden: oldItems\n      });\n\n      this._shrink(oldItems);\n\n      this.sort();\n\n      // Update the list of items here because `remove` could be called again\n      // with an item that is in the process of being removed.\n      this.items = this.items.filter(function (item) {\n        return !arrayIncludes(oldItems, item);\n      });\n      this._updateItemCount();\n\n      this.element.addEventListener(Shuffle.EventType.LAYOUT, handleLayout);\n    }\n\n    /**\n     * Retrieve a shuffle item by its element.\n     * @param {Element} element Element to look for.\n     * @return {?ShuffleItem} A shuffle item or null if it's not found.\n     */\n\n  }, {\n    key: 'getItemByElement',\n    value: function getItemByElement(element) {\n      for (var i = this.items.length - 1; i >= 0; i--) {\n        if (this.items[i].element === element) {\n          return this.items[i];\n        }\n      }\n\n      return null;\n    }\n\n    /**\n     * Destroys shuffle, removes events, styles, and classes\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._cancelMovement();\n      window.removeEventListener('resize', this._onResize);\n\n      // Reset container styles\n      this.element.classList.remove('shuffle');\n      this.element.removeAttribute('style');\n\n      // Reset individual item styles\n      this._disposeItems();\n\n      // Null DOM references\n      this.items = null;\n      this.options.sizer = null;\n      this.element = null;\n      this._transitions = null;\n\n      // Set a flag so if a debounced resize has been triggered,\n      // it can first check if it is actually isDestroyed and not doing anything\n      this.isDestroyed = true;\n    }\n\n    /**\n     * Returns the outer width of an element, optionally including its margins.\n     *\n     * There are a few different methods for getting the width of an element, none of\n     * which work perfectly for all Shuffle's use cases.\n     *\n     * 1. getBoundingClientRect() `left` and `right` properties.\n     *   - Accounts for transform scaled elements, making it useless for Shuffle\n     *   elements which have shrunk.\n     * 2. The `offsetWidth` property.\n     *   - This value stays the same regardless of the elements transform property,\n     *   however, it does not return subpixel values.\n     * 3. getComputedStyle()\n     *   - This works great Chrome, Firefox, Safari, but IE<=11 does not include\n     *   padding and border when box-sizing: border-box is set, requiring a feature\n     *   test and extra work to add the padding back for IE and other browsers which\n     *   follow the W3C spec here.\n     *\n     * @param {Element} element The element.\n     * @param {boolean} [includeMargins] Whether to include margins. Default is false.\n     * @return {{width: number, height: number}} The width and height.\n     */\n\n  }], [{\n    key: 'getSize',\n    value: function getSize(element, includeMargins) {\n      // Store the styles so that they can be used by others without asking for it again.\n      var styles = window.getComputedStyle(element, null);\n      var width = getNumberStyle(element, 'width', styles);\n      var height = getNumberStyle(element, 'height', styles);\n\n      if (includeMargins) {\n        var marginLeft = getNumberStyle(element, 'marginLeft', styles);\n        var marginRight = getNumberStyle(element, 'marginRight', styles);\n        var marginTop = getNumberStyle(element, 'marginTop', styles);\n        var marginBottom = getNumberStyle(element, 'marginBottom', styles);\n        width += marginLeft + marginRight;\n        height += marginTop + marginBottom;\n      }\n\n      return {\n        width: width,\n        height: height\n      };\n    }\n\n    /**\n     * Change a property or execute a function which will not have a transition\n     * @param {Array.<Element>} elements DOM elements that won't be transitioned.\n     * @param {Function} callback A function which will be called while transition\n     *     is set to 0ms.\n     * @private\n     */\n\n  }, {\n    key: '_skipTransitions',\n    value: function _skipTransitions(elements, callback) {\n      var zero = '0ms';\n\n      // Save current duration and delay.\n      var data = elements.map(function (element) {\n        var style = element.style;\n        var duration = style.transitionDuration;\n        var delay = style.transitionDelay;\n\n        // Set the duration to zero so it happens immediately\n        style.transitionDuration = zero;\n        style.transitionDelay = zero;\n\n        return {\n          duration: duration,\n          delay: delay\n        };\n      });\n\n      callback();\n\n      // Cause reflow.\n      elements[0].offsetWidth; // eslint-disable-line no-unused-expressions\n\n      // Put the duration back\n      elements.forEach(function (element, i) {\n        element.style.transitionDuration = data[i].duration;\n        element.style.transitionDelay = data[i].delay;\n      });\n    }\n  }]);\n  return Shuffle;\n}();\n\nShuffle.ShuffleItem = ShuffleItem;\n\nShuffle.ALL_ITEMS = 'all';\nShuffle.FILTER_ATTRIBUTE_KEY = 'groups';\n\n/**\n * @enum {string}\n */\nShuffle.EventType = {\n  LAYOUT: 'shuffle:layout',\n  REMOVED: 'shuffle:removed'\n};\n\n/** @enum {string} */\nShuffle.Classes = Classes;\n\n/**\n * @enum {string}\n */\nShuffle.FilterMode = {\n  ANY: 'any',\n  ALL: 'all'\n};\n\n// Overrideable options\nShuffle.options = {\n  // Initial filter group.\n  group: Shuffle.ALL_ITEMS,\n\n  // Transition/animation speed (milliseconds).\n  speed: 250,\n\n  // CSS easing function to use.\n  easing: 'ease',\n\n  // e.g. '.picture-item'.\n  itemSelector: '*',\n\n  // Element or selector string. Use an element to determine the size of columns\n  // and gutters.\n  sizer: null,\n\n  // A static number or function that tells the plugin how wide the gutters\n  // between columns are (in pixels).\n  gutterWidth: 0,\n\n  // A static number or function that returns a number which tells the plugin\n  // how wide the columns are (in pixels).\n  columnWidth: 0,\n\n  // If your group is not json, and is comma delimeted, you could set delimeter\n  // to ','.\n  delimeter: null,\n\n  // Useful for percentage based heights when they might not always be exactly\n  // the same (in pixels).\n  buffer: 0,\n\n  // Reading the width of elements isn't precise enough and can cause columns to\n  // jump between values.\n  columnThreshold: 0.01,\n\n  // Shuffle can be isInitialized with a sort object. It is the same object\n  // given to the sort method.\n  initialSort: null,\n\n  // By default, shuffle will throttle resize events. This can be changed or\n  // removed.\n  throttle: index$2,\n\n  // How often shuffle can be called on resize (in milliseconds).\n  throttleTime: 300,\n\n  // Transition delay offset for each item in milliseconds.\n  staggerAmount: 15,\n\n  // Maximum stagger delay in milliseconds.\n  staggerAmountMax: 250,\n\n  // Whether to use transforms or absolute positioning.\n  useTransforms: true,\n\n  // Affects using an array with filter. e.g. `filter(['one', 'two'])`. With \"any\",\n  // the element passes the test if any of its groups are in the array. With \"all\",\n  // the element only passes if all groups are in the array.\n  filterMode: Shuffle.FilterMode.ANY\n};\n\n// Expose for testing. Hack at your own risk.\nShuffle.__Point = Point;\nShuffle.__sorter = sorter;\nShuffle.__getColumnSpan = getColumnSpan;\nShuffle.__getAvailablePositions = getAvailablePositions;\nShuffle.__getShortColumn = getShortColumn;\n\nreturn Shuffle;\n\n})));\n//# sourceMappingURL=shuffle.js.map\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NodWZmbGVqcy9kaXN0L3NodWZmbGUuanM/ZmFjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuc2h1ZmZsZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gUG9seWZpbGwgZm9yIGNyZWF0aW5nIEN1c3RvbUV2ZW50cyBvbiBJRTkvMTAvMTFcblxuLy8gY29kZSBwdWxsZWQgZnJvbTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kNHRvY2NoaW5pL2N1c3RvbWV2ZW50LXBvbHlmaWxsXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQjUG9seWZpbGxcblxudHJ5IHtcbiAgICB2YXIgY2UgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KCd0ZXN0Jyk7XG4gICAgY2UucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoY2UuZGVmYXVsdFByZXZlbnRlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAvLyBJRSBoYXMgcHJvYmxlbXMgd2l0aCAucHJldmVudERlZmF1bHQoKSBvbiBjdXN0b20gZXZlbnRzXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjMzNDkxOTFcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcHJldmVudCBkZWZhdWx0Jyk7XG4gICAgfVxufSBjYXRjaChlKSB7XG4gIHZhciBDdXN0b21FdmVudCQxID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtcykge1xuICAgIHZhciBldnQsIG9yaWdQcmV2ZW50O1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgIG9yaWdQcmV2ZW50ID0gZXZ0LnByZXZlbnREZWZhdWx0O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9yaWdQcmV2ZW50LmNhbGwodGhpcyk7XG4gICAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RlZmF1bHRQcmV2ZW50ZWQnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZXZ0O1xuICB9O1xuXG4gIEN1c3RvbUV2ZW50JDEucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQkMTsgLy8gZXhwb3NlIGRlZmluaXRpb24gdG8gd2luZG93XG59XG5cbnZhciBwcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xudmFyIHZlbmRvciA9IHByb3RvLm1hdGNoZXNcbiAgfHwgcHJvdG8ubWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ubXNNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ub01hdGNoZXNTZWxlY3RvcjtcblxudmFyIGluZGV4ID0gbWF0Y2g7XG5cbi8qKlxuICogTWF0Y2ggYGVsYCB0byBgc2VsZWN0b3JgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2goZWwsIHNlbGVjdG9yKSB7XG4gIGlmICh2ZW5kb3IpIHJldHVybiB2ZW5kb3IuY2FsbChlbCwgc2VsZWN0b3IpO1xuICB2YXIgbm9kZXMgPSBlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldID09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cblxuXG5cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBpbmRleCQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyB0aGVyZSdzIDMgaW1wbGVtZW50YXRpb25zIHdyaXR0ZW4gaW4gaW5jcmVhc2luZyBvcmRlciBvZiBlZmZpY2llbmN5XG5cbi8vIDEgLSBubyBTZXQgdHlwZSBpcyBkZWZpbmVkXG5mdW5jdGlvbiB1bmlxTm9TZXQoYXJyKSB7XG5cdHZhciByZXQgPSBbXTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChyZXQuaW5kZXhPZihhcnJbaV0pID09PSAtMSkge1xuXHRcdFx0cmV0LnB1c2goYXJyW2ldKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG4vLyAyIC0gYSBzaW1wbGUgU2V0IHR5cGUgaXMgZGVmaW5lZFxuZnVuY3Rpb24gdW5pcVNldChhcnIpIHtcblx0dmFyIHNlZW4gPSBuZXcgU2V0KCk7XG5cdHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuXHRcdGlmICghc2Vlbi5oYXMoZWwpKSB7XG5cdFx0XHRzZWVuLmFkZChlbCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pO1xufVxuXG4vLyAzIC0gYSBzdGFuZGFyZCBTZXQgdHlwZSBpcyBkZWZpbmVkIGFuZCBpdCBoYXMgYSBmb3JFYWNoIG1ldGhvZFxuZnVuY3Rpb24gdW5pcVNldFdpdGhGb3JFYWNoKGFycikge1xuXHR2YXIgcmV0ID0gW107XG5cblx0KG5ldyBTZXQoYXJyKSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcblx0XHRyZXQucHVzaChlbCk7XG5cdH0pO1xuXG5cdHJldHVybiByZXQ7XG59XG5cbi8vIFY4IGN1cnJlbnRseSBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvODQ0OVxuZnVuY3Rpb24gZG9lc0ZvckVhY2hBY3R1YWxseVdvcmsoKSB7XG5cdHZhciByZXQgPSBmYWxzZTtcblxuXHQobmV3IFNldChbdHJ1ZV0pKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuXHRcdHJldCA9IGVsO1xuXHR9KTtcblxuXHRyZXR1cm4gcmV0ID09PSB0cnVlO1xufVxuXG5pZiAoJ1NldCcgaW4gY29tbW9uanNHbG9iYWwpIHtcblx0aWYgKHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2ggPT09ICdmdW5jdGlvbicgJiYgZG9lc0ZvckVhY2hBY3R1YWxseVdvcmsoKSkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gdW5pcVNldFdpdGhGb3JFYWNoO1xuXHR9IGVsc2Uge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gdW5pcVNldDtcblx0fVxufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmlxTm9TZXQ7XG59XG59KTtcblxudmFyIGltbXV0YWJsZSA9IGV4dGVuZDtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cblxudmFyIGluZGV4JDIgPSB0aHJvdHRsZTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQsIHdoZW4gaW52b2tlZCwgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlciBgd2FpdGAgbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0IE51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBtdXN0IGVsYXBzZSBiZXR3ZWVuIGBmdW5jYCBpbnZvY2F0aW9ucy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZSBgZnVuY2AgZnVuY3Rpb24gcGFzc2VkIGluLlxuICovXG5cbmZ1bmN0aW9uIHRocm90dGxlIChmdW5jLCB3YWl0KSB7XG4gIHZhciBjdHgsIGFyZ3MsIHJ0biwgdGltZW91dElEOyAvLyBjYWNoaW5nXG4gIHZhciBsYXN0ID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGVkICgpIHtcbiAgICBjdHggPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGRlbHRhID0gbmV3IERhdGUoKSAtIGxhc3Q7XG4gICAgaWYgKCF0aW1lb3V0SUQpXG4gICAgICBpZiAoZGVsdGEgPj0gd2FpdCkgY2FsbCgpO1xuICAgICAgZWxzZSB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGNhbGwsIHdhaXQgLSBkZWx0YSk7XG4gICAgcmV0dXJuIHJ0bjtcbiAgfTtcblxuICBmdW5jdGlvbiBjYWxsICgpIHtcbiAgICB0aW1lb3V0SUQgPSAwO1xuICAgIGxhc3QgPSArbmV3IERhdGUoKTtcbiAgICBydG4gPSBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgY3R4ID0gbnVsbDtcbiAgICBhcmdzID0gbnVsbDtcbiAgfVxufVxuXG52YXIgaW5kZXgkMyA9IGZ1bmN0aW9uIHBhcmFsbGVsKGZucywgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBjb250ZXh0O1xuICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZyA9IGZucyAmJiBmbnMubGVuZ3RoO1xuICBpZiAoIXBlbmRpbmcpIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG5cbiAgdmFyIGZpbmlzaGVkID0gZmFsc2U7XG4gIHZhciByZXN1bHRzID0gbmV3IEFycmF5KHBlbmRpbmcpO1xuXG4gIGZucy5mb3JFYWNoKGNvbnRleHQgPyBmdW5jdGlvbiAoZm4sIGkpIHtcbiAgICBmbi5jYWxsKGNvbnRleHQsIG1heWJlRG9uZShpKSk7XG4gIH0gOiBmdW5jdGlvbiAoZm4sIGkpIHtcbiAgICBmbihtYXliZURvbmUoaSkpO1xuICB9KTtcblxuICBmdW5jdGlvbiBtYXliZURvbmUoaSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgIGlmIChmaW5pc2hlZCkgcmV0dXJuO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XG5cbiAgICAgIGlmICghLS1wZW5kaW5nKSBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIGEgbnVtZXJpYyB2YWx1ZSwgZ2l2ZW4gYSB2YWx1ZS4gTG9naWMgZnJvbSBqUXVlcnkncyBgaXNOdW1lcmljYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUG9zc2libHkgbnVtZXJpYyB2YWx1ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gYHZhbHVlYCBvciB6ZXJvIGlmIGB2YWx1ZWAgaXNuJ3QgbnVtZXJpYy5cbiAqL1xuZnVuY3Rpb24gZ2V0TnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBjb29yZGluYXRlIHBhaXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gWS5cbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb2ludCk7XG5cbiAgICB0aGlzLnggPSBnZXROdW1iZXIoeCk7XG4gICAgdGhpcy55ID0gZ2V0TnVtYmVyKHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdHdvIHBvaW50cyBhcmUgZXF1YWwuXG4gICAqIEBwYXJhbSB7UG9pbnR9IGEgUG9pbnQgQS5cbiAgICogQHBhcmFtIHtQb2ludH0gYiBQb2ludCBCLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKFBvaW50LCBudWxsLCBbe1xuICAgIGtleTogJ2VxdWFscycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICByZXR1cm4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQb2ludDtcbn0oKTtcblxudmFyIENsYXNzZXMgPSB7XG4gIEJBU0U6ICdzaHVmZmxlJyxcbiAgU0hVRkZMRV9JVEVNOiAnc2h1ZmZsZS1pdGVtJyxcbiAgVklTSUJMRTogJ3NodWZmbGUtaXRlbS0tdmlzaWJsZScsXG4gIEhJRERFTjogJ3NodWZmbGUtaXRlbS0taGlkZGVuJ1xufTtcblxudmFyIGlkJDEgPSAwO1xuXG52YXIgU2h1ZmZsZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNodWZmbGVJdGVtKGVsZW1lbnQpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTaHVmZmxlSXRlbSk7XG5cbiAgICBpZCQxICs9IDE7XG4gICAgdGhpcy5pZCA9IGlkJDE7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhTaHVmZmxlSXRlbSwgW3tcbiAgICBrZXk6ICdzaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENsYXNzZXMuSElEREVOKTtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKENsYXNzZXMuVklTSUJMRSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ2xhc3Nlcy5WSVNJQkxFKTtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKENsYXNzZXMuSElEREVOKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3NlcyhbQ2xhc3Nlcy5TSFVGRkxFX0lURU0sIENsYXNzZXMuVklTSUJMRV0pO1xuICAgICAgdGhpcy5hcHBseUNzcyhTaHVmZmxlSXRlbS5Dc3MuSU5JVElBTCk7XG4gICAgICB0aGlzLnNjYWxlID0gU2h1ZmZsZUl0ZW0uU2NhbGUuVklTSUJMRTtcbiAgICAgIHRoaXMucG9pbnQgPSBuZXcgUG9pbnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRDbGFzc2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICBfdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZUNsYXNzZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKGNsYXNzZXMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICBfdGhpczIuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhcHBseUNzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5Q3NzKG9iaikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF90aGlzMy5lbGVtZW50LnN0eWxlW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc3Bvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzc2VzKFtDbGFzc2VzLkhJRERFTiwgQ2xhc3Nlcy5WSVNJQkxFLCBDbGFzc2VzLlNIVUZGTEVfSVRFTV0pO1xuXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNodWZmbGVJdGVtO1xufSgpO1xuXG5TaHVmZmxlSXRlbS5Dc3MgPSB7XG4gIElOSVRJQUw6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICB2aXNpYmlsaXR5OiAndmlzaWJsZScsXG4gICAgJ3dpbGwtY2hhbmdlJzogJ3RyYW5zZm9ybSdcbiAgfSxcbiAgVklTSUJMRToge1xuICAgIGJlZm9yZToge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuICAgIH0sXG4gICAgYWZ0ZXI6IHt9XG4gIH0sXG4gIEhJRERFTjoge1xuICAgIGJlZm9yZToge1xuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG4gICAgYWZ0ZXI6IHtcbiAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nXG4gICAgfVxuICB9XG59O1xuXG5TaHVmZmxlSXRlbS5TY2FsZSA9IHtcbiAgVklTSUJMRTogMSxcbiAgSElEREVOOiAwLjAwMVxufTtcblxudmFyIGVsZW1lbnQgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbnZhciBlJDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmUkMS5zdHlsZS5jc3NUZXh0ID0gJ3dpZHRoOjEwcHg7cGFkZGluZzoycHg7Ym94LXNpemluZzpib3JkZXItYm94Oyc7XG5lbGVtZW50LmFwcGVuZENoaWxkKGUkMSk7XG5cbnZhciB3aWR0aCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUkMSwgbnVsbCkud2lkdGg7XG52YXIgcmV0ID0gd2lkdGggPT09ICcxMHB4JztcblxuZWxlbWVudC5yZW1vdmVDaGlsZChlJDEpO1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjb21wdXRlZCBzdHlsZSBmb3IgYW4gZWxlbWVudCwgcGFyc2VkIGFzIGEgZmxvYXQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBnZXQgc3R5bGUgZm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlIFN0eWxlIHByb3BlcnR5LlxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBbc3R5bGVzXSBPcHRpb25hbGx5IGluY2x1ZGUgY2xlYW4gc3R5bGVzIHRvXG4gKiAgICAgdXNlIGluc3RlYWQgb2YgYXNraW5nIGZvciB0aGVtIGFnYWluLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcGFyc2VkIGNvbXB1dGVkIHZhbHVlIG9yIHplcm8gaWYgdGhhdCBmYWlscyBiZWNhdXNlIElFXG4gKiAgICAgd2lsbCByZXR1cm4gJ2F1dG8nIHdoZW4gdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIG1hcmdpbnMgaW5zdGVhZCBvZlxuICogICAgIHRoZSBjb21wdXRlZCBzdHlsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TnVtYmVyU3R5bGUoZWxlbWVudCwgc3R5bGUpIHtcbiAgdmFyIHN0eWxlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5cbiAgdmFyIHZhbHVlID0gZ2V0TnVtYmVyKHN0eWxlc1tzdHlsZV0pO1xuXG4gIC8vIFN1cHBvcnQgSUU8PTExIGFuZCBXM0Mgc3BlYy5cbiAgaWYgKCFyZXQgJiYgc3R5bGUgPT09ICd3aWR0aCcpIHtcbiAgICB2YWx1ZSArPSBnZXROdW1iZXIoc3R5bGVzLnBhZGRpbmdMZWZ0KSArIGdldE51bWJlcihzdHlsZXMucGFkZGluZ1JpZ2h0KSArIGdldE51bWJlcihzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKSArIGdldE51bWJlcihzdHlsZXMuYm9yZGVyUmlnaHRXaWR0aCk7XG4gIH0gZWxzZSBpZiAoIXJldCAmJiBzdHlsZSA9PT0gJ2hlaWdodCcpIHtcbiAgICB2YWx1ZSArPSBnZXROdW1iZXIoc3R5bGVzLnBhZGRpbmdUb3ApICsgZ2V0TnVtYmVyKHN0eWxlcy5wYWRkaW5nQm90dG9tKSArIGdldE51bWJlcihzdHlsZXMuYm9yZGVyVG9wV2lkdGgpICsgZ2V0TnVtYmVyKHN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogRmlzaGVyLVlhdGVzIHNodWZmbGUuXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85NjI4OTAvMzczNDIyXG4gKiBodHRwczovL2Jvc3Qub2Nrcy5vcmcvbWlrZS9zaHVmZmxlL1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm4ge0FycmF5fSBSYW5kb21seSBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbWl6ZShhcnJheSkge1xuICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAobikge1xuICAgIG4gLT0gMTtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChuICsgMSkpO1xuICAgIHZhciB0ZW1wID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaV0gPSBhcnJheVtuXTtcbiAgICBhcnJheVtuXSA9IHRlbXA7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBkZWZhdWx0cyQxID0ge1xuICAvLyBVc2UgYXJyYXkucmV2ZXJzZSgpIHRvIHJldmVyc2UgdGhlIHJlc3VsdHNcbiAgcmV2ZXJzZTogZmFsc2UsXG5cbiAgLy8gU29ydGluZyBmdW5jdGlvblxuICBieTogbnVsbCxcblxuICAvLyBJZiB0cnVlLCB0aGlzIHdpbGwgc2tpcCB0aGUgc29ydGluZyBhbmQgcmV0dXJuIGEgcmFuZG9taXplZCBvcmRlciBpbiB0aGUgYXJyYXlcbiAgcmFuZG9taXplOiBmYWxzZSxcblxuICAvLyBEZXRlcm1pbmVzIHdoaWNoIHByb3BlcnR5IG9mIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkgaXMgcGFzc2VkIHRvIHRoZVxuICAvLyBzb3J0aW5nIG1ldGhvZC5cbiAga2V5OiAnZWxlbWVudCdcbn07XG5cbi8vIFlvdSBjYW4gcmV0dXJuIGB1bmRlZmluZWRgIGZyb20gdGhlIGBieWAgZnVuY3Rpb24gdG8gcmV2ZXJ0IHRvIERPTSBvcmRlci5cbmZ1bmN0aW9uIHNvcnRlcihhcnIsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBpbW11dGFibGUoZGVmYXVsdHMkMSwgb3B0aW9ucyk7XG4gIHZhciBvcmlnaW5hbCA9IFtdLnNsaWNlLmNhbGwoYXJyKTtcbiAgdmFyIHJldmVydCA9IGZhbHNlO1xuXG4gIGlmICghYXJyLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmIChvcHRzLnJhbmRvbWl6ZSkge1xuICAgIHJldHVybiByYW5kb21pemUoYXJyKTtcbiAgfVxuXG4gIC8vIFNvcnQgdGhlIGVsZW1lbnRzIGJ5IHRoZSBvcHRzLmJ5IGZ1bmN0aW9uLlxuICAvLyBJZiB3ZSBkb24ndCBoYXZlIG9wdHMuYnksIGRlZmF1bHQgdG8gRE9NIG9yZGVyXG4gIGlmICh0eXBlb2Ygb3B0cy5ieSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGFscmVhZHkga25vdyB3ZSB3YW50IHRvIHJldmVydFxuICAgICAgaWYgKHJldmVydCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbEEgPSBvcHRzLmJ5KGFbb3B0cy5rZXldKTtcbiAgICAgIHZhciB2YWxCID0gb3B0cy5ieShiW29wdHMua2V5XSk7XG5cbiAgICAgIC8vIElmIGJvdGggdmFsdWVzIGFyZSB1bmRlZmluZWQsIHVzZSB0aGUgRE9NIG9yZGVyXG4gICAgICBpZiAodmFsQSA9PT0gdW5kZWZpbmVkICYmIHZhbEIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXZlcnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbEEgPCB2YWxCIHx8IHZhbEEgPT09ICdzb3J0Rmlyc3QnIHx8IHZhbEIgPT09ICdzb3J0TGFzdCcpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsQSA+IHZhbEIgfHwgdmFsQSA9PT0gJ3NvcnRMYXN0JyB8fCB2YWxCID09PSAnc29ydEZpcnN0Jykge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXZlcnQgdG8gdGhlIG9yaWdpbmFsIGFycmF5IGlmIG5lY2Vzc2FyeVxuICBpZiAocmV2ZXJ0KSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG5cbiAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgIGFyci5yZXZlcnNlKCk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG52YXIgdHJhbnNpdGlvbnMgPSB7fTtcbnZhciBldmVudE5hbWUgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgY291bnQgPSAwO1xuXG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgY291bnQgKz0gMTtcbiAgcmV0dXJuIGV2ZW50TmFtZSArIGNvdW50O1xufVxuXG5mdW5jdGlvbiBjYW5jZWxUcmFuc2l0aW9uRW5kKGlkKSB7XG4gIGlmICh0cmFuc2l0aW9uc1tpZF0pIHtcbiAgICB0cmFuc2l0aW9uc1tpZF0uZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdHJhbnNpdGlvbnNbaWRdLmxpc3RlbmVyKTtcbiAgICB0cmFuc2l0aW9uc1tpZF0gPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgdmFyIGlkID0gdW5pcXVlSWQoKTtcbiAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoZXZ0KSB7XG4gICAgaWYgKGV2dC5jdXJyZW50VGFyZ2V0ID09PSBldnQudGFyZ2V0KSB7XG4gICAgICBjYW5jZWxUcmFuc2l0aW9uRW5kKGlkKTtcbiAgICAgIGNhbGxiYWNrKGV2dCk7XG4gICAgfVxuICB9O1xuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcblxuICB0cmFuc2l0aW9uc1tpZF0gPSB7IGVsZW1lbnQ6IGVsZW1lbnQsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuXG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gYXJyYXlNYXgoYXJyYXkpIHtcbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIGFycmF5KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItc3ByZWFkXG59XG5cbmZ1bmN0aW9uIGFycmF5TWluKGFycmF5KSB7XG4gIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBhcnJheSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXNwcmVhZFxufVxuXG4vKipcbiAqIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYW4gaXRlbXMgc3BhbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gaXRlbVdpZHRoIFdpZHRoIG9mIHRoZSBpdGVtLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbldpZHRoIFdpZHRoIG9mIHRoZSBjb2x1bW4gKGluY2x1ZGVzIGd1dHRlcikuXG4gKiBAcGFyYW0ge251bWJlcn0gY29sdW1ucyBUb3RhbCBudW1iZXIgb2YgY29sdW1uc1xuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBBIGJ1ZmZlciB2YWx1ZSBmb3IgdGhlIHNpemUgb2YgdGhlIGNvbHVtbiB0byBmaXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldENvbHVtblNwYW4oaXRlbVdpZHRoLCBjb2x1bW5XaWR0aCwgY29sdW1ucywgdGhyZXNob2xkKSB7XG4gIHZhciBjb2x1bW5TcGFuID0gaXRlbVdpZHRoIC8gY29sdW1uV2lkdGg7XG5cbiAgLy8gSWYgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcm91bmRlZCBjb2x1bW4gc3BhbiBudW1iZXIgYW5kIHRoZVxuICAvLyBjYWxjdWxhdGVkIGNvbHVtbiBzcGFuIG51bWJlciBpcyByZWFsbHkgc21hbGwsIHJvdW5kIHRoZSBudW1iZXIgdG9cbiAgLy8gbWFrZSBpdCBmaXQuXG4gIGlmIChNYXRoLmFicyhNYXRoLnJvdW5kKGNvbHVtblNwYW4pIC0gY29sdW1uU3BhbikgPCB0aHJlc2hvbGQpIHtcbiAgICAvLyBlLmcuIGNvbHVtblNwYW4gPSA0LjAwODk5NDUzOTAyOTg3NDVcbiAgICBjb2x1bW5TcGFuID0gTWF0aC5yb3VuZChjb2x1bW5TcGFuKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSB0aGUgY29sdW1uIHNwYW4gaXMgbm90IG1vcmUgdGhhbiB0aGUgYW1vdW50IG9mIGNvbHVtbnMgaW4gdGhlIHdob2xlIGxheW91dC5cbiAgcmV0dXJuIE1hdGgubWluKE1hdGguY2VpbChjb2x1bW5TcGFuKSwgY29sdW1ucyk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb2x1bW4gc2V0IHRvIHVzZSBmb3IgcGxhY2VtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtblNwYW4gVGhlIG51bWJlciBvZiBjb2x1bW5zIHRoaXMgY3VycmVudCBpdGVtIHNwYW5zLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnMgVGhlIHRvdGFsIGNvbHVtbnMgaW4gdGhlIGdyaWQuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNldGluZyB0aGUgY29sdW1uIHNldC5cbiAqL1xuZnVuY3Rpb24gZ2V0QXZhaWxhYmxlUG9zaXRpb25zKHBvc2l0aW9ucywgY29sdW1uU3BhbiwgY29sdW1ucykge1xuICAvLyBUaGUgaXRlbSBzcGFucyBvbmx5IG9uZSBjb2x1bW4uXG4gIGlmIChjb2x1bW5TcGFuID09PSAxKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfVxuXG4gIC8vIFRoZSBpdGVtIHNwYW5zIG1vcmUgdGhhbiBvbmUgY29sdW1uLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRpZmZlcmVudFxuICAvLyBwbGFjZXMgaXQgY291bGQgZml0IGhvcml6b250YWxseS5cbiAgLy8gVGhlIGdyb3VwIGNvdW50IGlzIHRoZSBudW1iZXIgb2YgcGxhY2VzIHdpdGhpbiB0aGUgcG9zaXRpb25zIHRoaXMgYmxvY2tcbiAgLy8gY291bGQgZml0LCBpZ25vcmluZyB0aGUgY3VycmVudCBwb3NpdGlvbnMgb2YgaXRlbXMuXG4gIC8vIEltYWdpbmUgYSAyIGNvbHVtbiBicmljayBhcyB0aGUgc2Vjb25kIGl0ZW0gaW4gYSA0IGNvbHVtbiBncmlkIHdpdGhcbiAgLy8gMTBweCBoZWlnaHQgZWFjaC4gRmluZCB0aGUgcGxhY2VzIGl0IHdvdWxkIGZpdDpcbiAgLy8gWzIwLCAxMCwgMTAsIDBdXG4gIC8vICB8ICAgfCAgIHxcbiAgLy8gICogICAqICAgKlxuICAvL1xuICAvLyBUaGVuIHRha2UgdGhlIHBsYWNlcyB3aGljaCBmaXQgYW5kIGdldCB0aGUgYmlnZ2VyIG9mIHRoZSB0d286XG4gIC8vIG1heChbMjAsIDEwXSksIG1heChbMTAsIDEwXSksIG1heChbMTAsIDBdKSA9IFsyMCwgMTAsIDBdXG4gIC8vXG4gIC8vIE5leHQsIGZpbmQgdGhlIGZpcnN0IHNtYWxsZXN0IG51bWJlciAodGhlIHNob3J0IGNvbHVtbikuXG4gIC8vIFsyMCwgMTAsIDBdXG4gIC8vICAgICAgICAgIHxcbiAgLy8gICAgICAgICAgKlxuICAvL1xuICAvLyBBbmQgdGhhdCdzIHdoZXJlIGl0IHNob3VsZCBiZSBwbGFjZWQhXG4gIC8vXG4gIC8vIEFub3RoZXIgZXhhbXBsZSB3aGVyZSB0aGUgc2Vjb25kIGNvbHVtbidzIGl0ZW0gZXh0ZW5kcyBwYXN0IHRoZSBmaXJzdDpcbiAgLy8gWzEwLCAyMCwgMTAsIDBdID0+IFsyMCwgMjAsIDEwXSA9PiAxMFxuICB2YXIgYXZhaWxhYmxlID0gW107XG5cbiAgLy8gRm9yIGhvdyBtYW55IHBvc3NpYmxlIHBvc2l0aW9ucyBmb3IgdGhpcyBpdGVtIHRoZXJlIGFyZS5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gY29sdW1ucyAtIGNvbHVtblNwYW47IGkrKykge1xuICAgIC8vIEZpbmQgdGhlIGJpZ2dlciB2YWx1ZSBmb3IgZWFjaCBwbGFjZSBpdCBjb3VsZCBmaXQuXG4gICAgYXZhaWxhYmxlLnB1c2goYXJyYXlNYXgocG9zaXRpb25zLnNsaWNlKGksIGkgKyBjb2x1bW5TcGFuKSkpO1xuICB9XG5cbiAgcmV0dXJuIGF2YWlsYWJsZTtcbn1cblxuLyoqXG4gKiBGaW5kIGluZGV4IG9mIHNob3J0IGNvbHVtbiwgdGhlIGZpcnN0IGZyb20gdGhlIGxlZnQgd2hlcmUgdGhpcyBpdGVtIHdpbGwgZ28uXG4gKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9zaXRpb25zIFRoZSBhcnJheSB0byBzZWFyY2ggZm9yIHRoZSBzbWFsbGVzdCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyIE9wdGlvbmFsIGJ1ZmZlciB3aGljaCBpcyB2ZXJ5IHVzZWZ1bCB3aGVuIHRoZSBoZWlnaHRcbiAqICAgICBpcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHdpZHRoLlxuICogQHJldHVybiB7bnVtYmVyfSBJbmRleCBvZiB0aGUgc2hvcnQgY29sdW1uLlxuICovXG5mdW5jdGlvbiBnZXRTaG9ydENvbHVtbihwb3NpdGlvbnMsIGJ1ZmZlcikge1xuICB2YXIgbWluUG9zaXRpb24gPSBhcnJheU1pbihwb3NpdGlvbnMpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHBvc2l0aW9uc1tpXSA+PSBtaW5Qb3NpdGlvbiAtIGJ1ZmZlciAmJiBwb3NpdGlvbnNbaV0gPD0gbWluUG9zaXRpb24gKyBidWZmZXIpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIERldGVybWluZSB0aGUgbG9jYXRpb24gb2YgdGhlIG5leHQgaXRlbSwgYmFzZWQgb24gaXRzIHNpemUuXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbVNpemUgT2JqZWN0IHdpdGggd2lkdGggYW5kIGhlaWdodC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvc2l0aW9ucyBQb3NpdGlvbnMgb2YgdGhlIG90aGVyIGN1cnJlbnQgaXRlbXMuXG4gKiBAcGFyYW0ge251bWJlcn0gZ3JpZFNpemUgVGhlIGNvbHVtbiB3aWR0aCBvciByb3cgaGVpZ2h0LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsIFRoZSB0b3RhbCBudW1iZXIgb2YgY29sdW1ucyBvciByb3dzLlxuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBCdWZmZXIgdmFsdWUgZm9yIHRoZSBjb2x1bW4gdG8gZml0LlxuICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlciBWZXJ0aWNhbCBidWZmZXIgZm9yIHRoZSBoZWlnaHQgb2YgaXRlbXMuXG4gKiBAcmV0dXJuIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlbVBvc2l0aW9uKF9yZWYpIHtcbiAgdmFyIGl0ZW1TaXplID0gX3JlZi5pdGVtU2l6ZSxcbiAgICAgIHBvc2l0aW9ucyA9IF9yZWYucG9zaXRpb25zLFxuICAgICAgZ3JpZFNpemUgPSBfcmVmLmdyaWRTaXplLFxuICAgICAgdG90YWwgPSBfcmVmLnRvdGFsLFxuICAgICAgdGhyZXNob2xkID0gX3JlZi50aHJlc2hvbGQsXG4gICAgICBidWZmZXIgPSBfcmVmLmJ1ZmZlcjtcblxuICB2YXIgc3BhbiA9IGdldENvbHVtblNwYW4oaXRlbVNpemUud2lkdGgsIGdyaWRTaXplLCB0b3RhbCwgdGhyZXNob2xkKTtcbiAgdmFyIHNldFkgPSBnZXRBdmFpbGFibGVQb3NpdGlvbnMocG9zaXRpb25zLCBzcGFuLCB0b3RhbCk7XG4gIHZhciBzaG9ydENvbHVtbkluZGV4ID0gZ2V0U2hvcnRDb2x1bW4oc2V0WSwgYnVmZmVyKTtcblxuICAvLyBQb3NpdGlvbiB0aGUgaXRlbVxuICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoTWF0aC5yb3VuZChncmlkU2l6ZSAqIHNob3J0Q29sdW1uSW5kZXgpLCBNYXRoLnJvdW5kKHNldFlbc2hvcnRDb2x1bW5JbmRleF0pKTtcblxuICAvLyBVcGRhdGUgdGhlIGNvbHVtbnMgYXJyYXkgd2l0aCB0aGUgbmV3IHZhbHVlcyBmb3IgZWFjaCBjb2x1bW4uXG4gIC8vIGUuZy4gYmVmb3JlIHRoZSB1cGRhdGUgdGhlIGNvbHVtbnMgY291bGQgYmUgWzI1MCwgMCwgMCwgMF0gZm9yIGFuIGl0ZW1cbiAgLy8gd2hpY2ggc3BhbnMgMiBjb2x1bW5zLiBBZnRlciBpdCB3b3VsZCBiZSBbMjUwLCBpdGVtSGVpZ2h0LCBpdGVtSGVpZ2h0LCAwXS5cbiAgdmFyIHNldEhlaWdodCA9IHNldFlbc2hvcnRDb2x1bW5JbmRleF0gKyBpdGVtU2l6ZS5oZWlnaHQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbjsgaSsrKSB7XG4gICAgcG9zaXRpb25zW3Nob3J0Q29sdW1uSW5kZXggKyBpXSA9IHNldEhlaWdodDtcbiAgfVxuXG4gIHJldHVybiBwb2ludDtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSQkMShhcnJheUxpa2UpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59XG5cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIG9iaikge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihvYmopID4gLTE7XG59XG5cbi8vIFVzZWQgZm9yIHVuaXF1ZSBpbnN0YW5jZSB2YXJpYWJsZXNcbnZhciBpZCA9IDA7XG5cbnZhciBTaHVmZmxlID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDYXRlZ29yaXplLCBzb3J0LCBhbmQgZmlsdGVyIGEgcmVzcG9uc2l2ZSBncmlkIG9mIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgQW4gZWxlbWVudCB3aGljaCBpcyB0aGUgcGFyZW50IGNvbnRhaW5lciBmb3IgdGhlIGdyaWQgaXRlbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz1TaHVmZmxlLm9wdGlvbnNdIE9wdGlvbnMgb2JqZWN0LlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFNodWZmbGUoZWxlbWVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTaHVmZmxlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IGltbXV0YWJsZShTaHVmZmxlLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy51c2VTaXplciA9IGZhbHNlO1xuICAgIHRoaXMubGFzdFNvcnQgPSB7fTtcbiAgICB0aGlzLmdyb3VwID0gU2h1ZmZsZS5BTExfSVRFTVM7XG4gICAgdGhpcy5sYXN0RmlsdGVyID0gU2h1ZmZsZS5BTExfSVRFTVM7XG4gICAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl90cmFuc2l0aW9ucyA9IFtdO1xuICAgIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcblxuICAgIHZhciBlbCA9IHRoaXMuX2dldEVsZW1lbnRPcHRpb24oZWxlbWVudCk7XG5cbiAgICBpZiAoIWVsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaHVmZmxlIG5lZWRzIHRvIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbDtcbiAgICB0aGlzLmlkID0gJ3NodWZmbGVfJyArIGlkO1xuICAgIGlkICs9IDE7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFNodWZmbGUsIFt7XG4gICAga2V5OiAnX2luaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLl9nZXRJdGVtcygpO1xuXG4gICAgICB0aGlzLm9wdGlvbnMuc2l6ZXIgPSB0aGlzLl9nZXRFbGVtZW50T3B0aW9uKHRoaXMub3B0aW9ucy5zaXplcik7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2l6ZXIpIHtcbiAgICAgICAgdGhpcy51c2VTaXplciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBjbGFzcyBhbmQgaW52YWxpZGF0ZSBzdHlsZXNcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFNodWZmbGUuQ2xhc3Nlcy5CQVNFKTtcblxuICAgICAgLy8gU2V0IGluaXRpYWwgY3NzIGZvciBlYWNoIGl0ZW1cbiAgICAgIHRoaXMuX2luaXRJdGVtcygpO1xuXG4gICAgICAvLyBCaW5kIHJlc2l6ZSBldmVudHNcbiAgICAgIHRoaXMuX29uUmVzaXplID0gdGhpcy5fZ2V0UmVzaXplRnVuY3Rpb24oKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG5cbiAgICAgIC8vIEdldCBjb250YWluZXIgY3NzIGFsbCBpbiBvbmUgcmVxdWVzdC4gQ2F1c2VzIHJlZmxvd1xuICAgICAgdmFyIGNvbnRhaW5lckNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCwgbnVsbCk7XG4gICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBTaHVmZmxlLmdldFNpemUodGhpcy5lbGVtZW50KS53aWR0aDtcblxuICAgICAgLy8gQWRkIHN0eWxlcyB0byB0aGUgY29udGFpbmVyIGlmIGl0IGRvZXNuJ3QgaGF2ZSB0aGVtLlxuICAgICAgdGhpcy5fdmFsaWRhdGVTdHlsZXMoY29udGFpbmVyQ3NzKTtcblxuICAgICAgLy8gV2UgYWxyZWFkeSBnb3QgdGhlIGNvbnRhaW5lcidzIHdpZHRoIGFib3ZlLCBubyBuZWVkIHRvIGNhdXNlIGFub3RoZXJcbiAgICAgIC8vIHJlZmxvdyBnZXR0aW5nIGl0IGFnYWluLi4uIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgdGhlcmUgd2lsbCBiZVxuICAgICAgdGhpcy5fc2V0Q29sdW1ucyhjb250YWluZXJXaWR0aCk7XG5cbiAgICAgIC8vIEtpY2sgb2ZmIVxuICAgICAgdGhpcy5maWx0ZXIodGhpcy5vcHRpb25zLmdyb3VwLCB0aGlzLm9wdGlvbnMuaW5pdGlhbFNvcnQpO1xuXG4gICAgICAvLyBUaGUgc2h1ZmZsZSBpdGVtcyBoYXZlbid0IGhhZCB0cmFuc2l0aW9ucyBzZXQgb24gdGhlbSB5ZXQgc28gdGhlIHVzZXJcbiAgICAgIC8vIGRvZXNuJ3Qgc2VlIHRoZSBmaXJzdCBsYXlvdXQuIFNldCB0aGVtIG5vdyB0aGF0IHRoZSBmaXJzdCBsYXlvdXQgaXMgZG9uZS5cbiAgICAgIC8vIEZpcnN0LCBob3dldmVyLCBhIHN5bmNocm9ub3VzIGxheW91dCBtdXN0IGJlIGNhdXNlZCBmb3IgdGhlIHByZXZpb3VzXG4gICAgICAvLyBzdHlsZXMgdG8gYmUgYXBwbGllZCB3aXRob3V0IHRyYW5zaXRpb25zLlxuICAgICAgdGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgdGhpcy5fc2V0VHJhbnNpdGlvbnMoKTtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gJ2hlaWdodCAnICsgdGhpcy5vcHRpb25zLnNwZWVkICsgJ21zICcgKyB0aGlzLm9wdGlvbnMuZWFzaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0aHJvdHRsZWQgYW5kIHByb3hpZWQgZnVuY3Rpb24gZm9yIHRoZSByZXNpemUgaGFuZGxlci5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0UmVzaXplRnVuY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UmVzaXplRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzaXplRnVuY3Rpb24gPSB0aGlzLl9oYW5kbGVSZXNpemUuYmluZCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGhyb3R0bGUgPyB0aGlzLm9wdGlvbnMudGhyb3R0bGUocmVzaXplRnVuY3Rpb24sIHRoaXMub3B0aW9ucy50aHJvdHRsZVRpbWUpIDogcmVzaXplRnVuY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYW4gZWxlbWVudCBmcm9tIGFuIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xqUXVlcnl8RWxlbWVudH0gb3B0aW9uIFRoZSBvcHRpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7P0VsZW1lbnR9IFRoZSBwbGFpbiBlbGVtZW50IG9yIG51bGwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldEVsZW1lbnRPcHRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RWxlbWVudE9wdGlvbihvcHRpb24pIHtcbiAgICAgIC8vIElmIGNvbHVtbiB3aWR0aCBpcyBhIHN0cmluZywgdHJlYXQgaXMgYXMgYSBzZWxlY3RvciBhbmQgc2VhcmNoIGZvciB0aGVcbiAgICAgIC8vIHNpemVyIGVsZW1lbnQgd2l0aGluIHRoZSBvdXRlcm1vc3QgY29udGFpbmVyXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvbik7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFuIGVsZW1lbnRcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9uICYmIG9wdGlvbi5ub2RlVHlwZSAmJiBvcHRpb24ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbjtcblxuICAgICAgICAvLyBDaGVjayBmb3IgalF1ZXJ5IG9iamVjdFxuICAgICAgfSBlbHNlIGlmIChvcHRpb24gJiYgb3B0aW9uLmpxdWVyeSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoZSBzaHVmZmxlIGNvbnRhaW5lciBoYXMgdGhlIGNzcyBzdHlsZXMgaXQgbmVlZHMgYXBwbGllZCB0byBpdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIEtleSB2YWx1ZSBwYWlycyBmb3IgcG9zaXRpb24gYW5kIG92ZXJmbG93LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ192YWxpZGF0ZVN0eWxlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZVN0eWxlcyhzdHlsZXMpIHtcbiAgICAgIC8vIFBvc2l0aW9uIGNhbm5vdCBiZSBzdGF0aWMuXG4gICAgICBpZiAoc3R5bGVzLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgfVxuXG4gICAgICAvLyBPdmVyZmxvdyBoYXMgdG8gYmUgaGlkZGVuLlxuICAgICAgaWYgKHN0eWxlcy5vdmVyZmxvdyAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHRoZSBlbGVtZW50cyBieSBhIGNhdGVnb3J5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2F0ZWdvcnldIENhdGVnb3J5IHRvIGZpbHRlciBieS4gSWYgaXQncyBnaXZlbiwgdGhlIGxhc3RcbiAgICAgKiAgICAgY2F0ZWdvcnkgd2lsbCBiZSB1c2VkIHRvIGZpbHRlciB0aGUgaXRlbXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbGxlY3Rpb25dIE9wdGlvbmFsbHkgZmlsdGVyIGEgY29sbGVjdGlvbi4gRGVmYXVsdHMgdG9cbiAgICAgKiAgICAgYWxsIHRoZSBpdGVtcy5cbiAgICAgKiBAcmV0dXJuIHshe3Zpc2libGU6IEFycmF5LCBoaWRkZW46IEFycmF5fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmlsdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbHRlcigpIHtcbiAgICAgIHZhciBjYXRlZ29yeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5sYXN0RmlsdGVyO1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuaXRlbXM7XG5cbiAgICAgIHZhciBzZXQkJDEgPSB0aGlzLl9nZXRGaWx0ZXJlZFNldHMoY2F0ZWdvcnksIGNvbGxlY3Rpb24pO1xuXG4gICAgICAvLyBJbmRpdmlkdWFsbHkgYWRkL3JlbW92ZSBoaWRkZW4vdmlzaWJsZSBjbGFzc2VzXG4gICAgICB0aGlzLl90b2dnbGVGaWx0ZXJDbGFzc2VzKHNldCQkMSk7XG5cbiAgICAgIC8vIFNhdmUgdGhlIGxhc3QgZmlsdGVyIGluIGNhc2UgZWxlbWVudHMgYXJlIGFwcGVuZGVkLlxuICAgICAgdGhpcy5sYXN0RmlsdGVyID0gY2F0ZWdvcnk7XG5cbiAgICAgIC8vIFRoaXMgaXMgc2F2ZWQgbWFpbmx5IGJlY2F1c2UgcHJvdmlkaW5nIGEgZmlsdGVyIGZ1bmN0aW9uIChsaWtlIHNlYXJjaGluZylcbiAgICAgIC8vIHdpbGwgb3ZlcndyaXRlIHRoZSBgbGFzdEZpbHRlcmAgcHJvcGVydHkgZXZlcnkgdGltZSBpdHMgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBjYXRlZ29yeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5ncm91cCA9IGNhdGVnb3J5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0JCQxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHZpc2libGUgYW5kIGhpZGRlbiBlbGVtZW50cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gY2F0ZWdvcnkgQ2F0ZWdvcnkgb3IgZnVuY3Rpb24gdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnQ+fSBpdGVtcyBBIGNvbGxlY3Rpb24gb2YgaXRlbXMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm4geyF7dmlzaWJsZTogQXJyYXksIGhpZGRlbjogQXJyYXl9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRGaWx0ZXJlZFNldHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RmlsdGVyZWRTZXRzKGNhdGVnb3J5LCBpdGVtcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHZpc2libGUgPSBbXTtcbiAgICAgIHZhciBoaWRkZW4gPSBbXTtcblxuICAgICAgLy8gY2F0ZWdvcnkgPT09ICdhbGwnLCBhZGQgdmlzaWJsZSBjbGFzcyB0byBldmVyeXRoaW5nXG4gICAgICBpZiAoY2F0ZWdvcnkgPT09IFNodWZmbGUuQUxMX0lURU1TKSB7XG4gICAgICAgIHZpc2libGUgPSBpdGVtcztcblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBpdGVtIGFuZCB1c2UgcHJvdmlkZWQgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gICAgICAgIC8vIHdoZXRoZXIgdG8gaGlkZSBpdCBvciBub3QuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKF90aGlzLl9kb2VzUGFzc0ZpbHRlcihjYXRlZ29yeSwgaXRlbS5lbGVtZW50KSkge1xuICAgICAgICAgICAgdmlzaWJsZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWRkZW4ucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2aXNpYmxlOiB2aXNpYmxlLFxuICAgICAgICBoaWRkZW46IGhpZGRlblxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGFuIGl0ZW0gdG8gc2VlIGlmIGl0IHBhc3NlcyBhIGNhdGVnb3J5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBjYXRlZ29yeSBDYXRlZ29yeSBvciBmdW5jdGlvbiB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEFuIGVsZW1lbnQgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGl0IHBhc3NlcyB0aGUgY2F0ZWdvcnkvZmlsdGVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kb2VzUGFzc0ZpbHRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kb2VzUGFzc0ZpbHRlcihjYXRlZ29yeSwgZWxlbWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBjYXRlZ29yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY2F0ZWdvcnkuY2FsbChlbGVtZW50LCBlbGVtZW50LCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZWFjaCBlbGVtZW50J3MgZGF0YS1ncm91cHMgYXR0cmlidXRlIGFnYWluc3QgdGhlIGdpdmVuIGNhdGVnb3J5LlxuICAgICAgdmFyIGF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgU2h1ZmZsZS5GSUxURVJfQVRUUklCVVRFX0tFWSk7XG4gICAgICB2YXIga2V5cyA9IHRoaXMub3B0aW9ucy5kZWxpbWV0ZXIgPyBhdHRyLnNwbGl0KHRoaXMub3B0aW9ucy5kZWxpbWV0ZXIpIDogSlNPTi5wYXJzZShhdHRyKTtcblxuICAgICAgZnVuY3Rpb24gdGVzdENhdGVnb3J5KGNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKGtleXMsIGNhdGVnb3J5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2F0ZWdvcnkpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsdGVyTW9kZSA9PT0gU2h1ZmZsZS5GaWx0ZXJNb2RlLkFOWSkge1xuICAgICAgICAgIHJldHVybiBjYXRlZ29yeS5zb21lKHRlc3RDYXRlZ29yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhdGVnb3J5LmV2ZXJ5KHRlc3RDYXRlZ29yeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKGtleXMsIGNhdGVnb3J5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmxlIGFuZCBoaWRkZW4gY2xhc3MgbmFtZXMuXG4gICAgICogQHBhcmFtIHt7dmlzaWJsZSwgaGlkZGVufX0gT2JqZWN0IHdpdGggdmlzaWJsZSBhbmQgaGlkZGVuIGFycmF5cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdG9nZ2xlRmlsdGVyQ2xhc3NlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVGaWx0ZXJDbGFzc2VzKF9yZWYpIHtcbiAgICAgIHZhciB2aXNpYmxlID0gX3JlZi52aXNpYmxlLFxuICAgICAgICAgIGhpZGRlbiA9IF9yZWYuaGlkZGVuO1xuXG4gICAgICB2aXNpYmxlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5zaG93KCk7XG4gICAgICB9KTtcblxuICAgICAgaGlkZGVuLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGluaXRpYWwgY3NzIGZvciBlYWNoIGl0ZW1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxTaHVmZmxlSXRlbT59IFtpdGVtc10gT3B0aW9uYWxseSBzcGVjaWZpeSBhdCBzZXQgdG8gaW5pdGlhbGl6ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaW5pdEl0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRJdGVtcygpIHtcbiAgICAgIHZhciBpdGVtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5pdGVtcztcblxuICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLmluaXQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBlbGVtZW50IHJlZmVyZW5jZSBhbmQgc3R5bGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19kaXNwb3NlSXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzcG9zZUl0ZW1zKCkge1xuICAgICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLml0ZW1zO1xuXG4gICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW0uZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmlzaWJsZSBpdGVtIGNvdW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVJdGVtQ291bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlSXRlbUNvdW50KCkge1xuICAgICAgdGhpcy52aXNpYmxlSXRlbXMgPSB0aGlzLl9nZXRGaWx0ZXJlZEl0ZW1zKCkubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgY3NzIHRyYW5zZm9ybSB0cmFuc2l0aW9uIG9uIGEgZ3JvdXAgb2YgZWxlbWVudHMuIFRoaXMgaXMgbm90IGV4ZWN1dGVkXG4gICAgICogYXQgdGhlIHNhbWUgdGltZSBhcyBgaXRlbS5pbml0YCBzbyB0aGF0IHRyYW5zaXRpb25zIGRvbid0IG9jY3VyIHVwb25cbiAgICAgKiBpbml0aWFsaXphdGlvbiBvZiBTaHVmZmxlLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFNodWZmbGVJdGVtPn0gaXRlbXMgU2h1ZmZsZSBpdGVtcyB0byBzZXQgdHJhbnNpdGlvbnMgb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldFRyYW5zaXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFRyYW5zaXRpb25zKCkge1xuICAgICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLml0ZW1zO1xuXG4gICAgICB2YXIgc3BlZWQgPSB0aGlzLm9wdGlvbnMuc3BlZWQ7XG4gICAgICB2YXIgZWFzaW5nID0gdGhpcy5vcHRpb25zLmVhc2luZztcblxuICAgICAgdmFyIHN0ciA9IHRoaXMub3B0aW9ucy51c2VUcmFuc2Zvcm1zID8gJ3RyYW5zZm9ybSAnICsgc3BlZWQgKyAnbXMgJyArIGVhc2luZyArICcsIG9wYWNpdHkgJyArIHNwZWVkICsgJ21zICcgKyBlYXNpbmcgOiAndG9wICcgKyBzcGVlZCArICdtcyAnICsgZWFzaW5nICsgJywgbGVmdCAnICsgc3BlZWQgKyAnbXMgJyArIGVhc2luZyArICcsIG9wYWNpdHkgJyArIHNwZWVkICsgJ21zICcgKyBlYXNpbmc7XG5cbiAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5lbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSBzdHI7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0SXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SXRlbXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRvQXJyYXkkJDEodGhpcy5lbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBpbmRleChlbCwgX3RoaXMyLm9wdGlvbnMuaXRlbVNlbGVjdG9yKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaHVmZmxlSXRlbShlbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIG5ldyBlbGVtZW50cyBhcmUgYWRkZWQgdG8gdGhlIHNodWZmbGUgY29udGFpbmVyLCB1cGRhdGUgdGhlIGFycmF5IG9mXG4gICAgICogaXRlbXMgYmVjYXVzZSB0aGF0IGlzIHRoZSBvcmRlciBgX2xheW91dGAgY2FsbHMgdGhlbS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3VwZGF0ZUl0ZW1zT3JkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlSXRlbXNPcmRlcigpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgIHRoaXMuaXRlbXMgPSBzb3J0ZXIodGhpcy5pdGVtcywge1xuICAgICAgICBieTogZnVuY3Rpb24gYnkoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGNoaWxkcmVuLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2dldEZpbHRlcmVkSXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RmlsdGVyZWRJdGVtcygpIHtcbiAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5pc1Zpc2libGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Q29uY2VhbGVkSXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29uY2VhbGVkSXRlbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICFpdGVtLmlzVmlzaWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbHVtbiBzaXplLCBiYXNlZCBvbiBjb2x1bW4gd2lkdGggYW5kIHNpemVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbnRhaW5lcldpZHRoIFNpemUgb2YgdGhlIHBhcmVudCBjb250YWluZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlclNpemUgU2l6ZSBvZiB0aGUgZ3V0dGVycy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldENvbHVtblNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29sdW1uU2l6ZShjb250YWluZXJXaWR0aCwgZ3V0dGVyU2l6ZSkge1xuICAgICAgdmFyIHNpemUgPSB2b2lkIDA7XG5cbiAgICAgIC8vIElmIHRoZSBjb2x1bW5XaWR0aCBwcm9wZXJ0eSBpcyBhIGZ1bmN0aW9uLCB0aGVuIHRoZSBncmlkIGlzIGZsdWlkXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5jb2x1bW5XaWR0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzaXplID0gdGhpcy5vcHRpb25zLmNvbHVtbldpZHRoKGNvbnRhaW5lcldpZHRoKTtcblxuICAgICAgICAvLyBjb2x1bW5XaWR0aCBvcHRpb24gaXNuJ3QgYSBmdW5jdGlvbiwgYXJlIHRoZXkgdXNpbmcgYSBzaXppbmcgZWxlbWVudD9cbiAgICAgIH0gZWxzZSBpZiAodGhpcy51c2VTaXplcikge1xuICAgICAgICBzaXplID0gU2h1ZmZsZS5nZXRTaXplKHRoaXMub3B0aW9ucy5zaXplcikud2lkdGg7XG5cbiAgICAgICAgLy8gaWYgbm90LCBob3cgYWJvdXQgdGhlIGV4cGxpY2l0bHkgc2V0IG9wdGlvbj9cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmNvbHVtbldpZHRoKSB7XG4gICAgICAgIHNpemUgPSB0aGlzLm9wdGlvbnMuY29sdW1uV2lkdGg7XG5cbiAgICAgICAgLy8gb3IgdXNlIHRoZSBzaXplIG9mIHRoZSBmaXJzdCBpdGVtXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzaXplID0gU2h1ZmZsZS5nZXRTaXplKHRoaXMuaXRlbXNbMF0uZWxlbWVudCwgdHJ1ZSkud2lkdGg7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUncyBubyBpdGVtcywgdXNlIHNpemUgb2YgY29udGFpbmVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gY29udGFpbmVyV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IGxldCB0aGVtIHNldCBhIGNvbHVtbiB3aWR0aCBvZiB6ZXJvLlxuICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgc2l6ZSA9IGNvbnRhaW5lcldpZHRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2l6ZSArIGd1dHRlclNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZ3V0dGVyIHNpemUsIGJhc2VkIG9uIGd1dHRlciB3aWR0aCBhbmQgc2l6ZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29udGFpbmVyV2lkdGggU2l6ZSBvZiB0aGUgcGFyZW50IGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldEd1dHRlclNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0R3V0dGVyU2l6ZShjb250YWluZXJXaWR0aCkge1xuICAgICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5ndXR0ZXJXaWR0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzaXplID0gdGhpcy5vcHRpb25zLmd1dHRlcldpZHRoKGNvbnRhaW5lcldpZHRoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy51c2VTaXplcikge1xuICAgICAgICBzaXplID0gZ2V0TnVtYmVyU3R5bGUodGhpcy5vcHRpb25zLnNpemVyLCAnbWFyZ2luTGVmdCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IHRoaXMub3B0aW9ucy5ndXR0ZXJXaWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgY29sdW1ucyB0byBiZSB1c2VkLiBHZXRzIGNzcyBpZiB1c2luZyBzaXplciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29udGFpbmVyV2lkdGhdIE9wdGlvbmFsbHkgc3BlY2lmeSBhIGNvbnRhaW5lciB3aWR0aCBpZlxuICAgICAqICAgIGl0J3MgYWxyZWFkeSBhdmFpbGFibGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19zZXRDb2x1bW5zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldENvbHVtbnMoKSB7XG4gICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFNodWZmbGUuZ2V0U2l6ZSh0aGlzLmVsZW1lbnQpLndpZHRoO1xuXG4gICAgICB2YXIgZ3V0dGVyID0gdGhpcy5fZ2V0R3V0dGVyU2l6ZShjb250YWluZXJXaWR0aCk7XG4gICAgICB2YXIgY29sdW1uV2lkdGggPSB0aGlzLl9nZXRDb2x1bW5TaXplKGNvbnRhaW5lcldpZHRoLCBndXR0ZXIpO1xuICAgICAgdmFyIGNhbGN1bGF0ZWRDb2x1bW5zID0gKGNvbnRhaW5lcldpZHRoICsgZ3V0dGVyKSAvIGNvbHVtbldpZHRoO1xuXG4gICAgICAvLyBXaWR0aHMgZ2l2ZW4gZnJvbSBnZXRTdHlsZXMgYXJlIG5vdCBwcmVjaXNlIGVub3VnaC4uLlxuICAgICAgaWYgKE1hdGguYWJzKE1hdGgucm91bmQoY2FsY3VsYXRlZENvbHVtbnMpIC0gY2FsY3VsYXRlZENvbHVtbnMpIDwgdGhpcy5vcHRpb25zLmNvbHVtblRocmVzaG9sZCkge1xuICAgICAgICAvLyBlLmcuIGNhbGN1bGF0ZWRDb2x1bW5zID0gMTEuOTk4ODc2XG4gICAgICAgIGNhbGN1bGF0ZWRDb2x1bW5zID0gTWF0aC5yb3VuZChjYWxjdWxhdGVkQ29sdW1ucyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29scyA9IE1hdGgubWF4KE1hdGguZmxvb3IoY2FsY3VsYXRlZENvbHVtbnMpLCAxKTtcbiAgICAgIHRoaXMuY29udGFpbmVyV2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgICAgIHRoaXMuY29sV2lkdGggPSBjb2x1bW5XaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIGhlaWdodCBvZiB0aGUgZ3JpZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0Q29udGFpbmVyU2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDb250YWluZXJTaXplKCkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuX2dldENvbnRhaW5lclNpemUoKSArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdGhlIGNvbHVtbiBoZWlnaHRzLCBpdCByZXR1cm5zIHRoZSBiaWdnZXN0IG9uZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldENvbnRhaW5lclNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29udGFpbmVyU2l6ZSgpIHtcbiAgICAgIHJldHVybiBhcnJheU1heCh0aGlzLnBvc2l0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbGFtcGVkIHN0YWdnZXIgYW1vdW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgaXRlbSB0byBiZSBzdGFnZ2VyZWQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0U3RhZ2dlckFtb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdGFnZ2VyQW1vdW50KGluZGV4JCQxKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oaW5kZXgkJDEgKiB0aGlzLm9wdGlvbnMuc3RhZ2dlckFtb3VudCwgdGhpcy5vcHRpb25zLnN0YWdnZXJBbW91bnRNYXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGV2ZW50IHdhcyBwcmV2ZW50ZWQgb3Igbm90LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGlzcGF0Y2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzcGF0Y2gobmFtZSkge1xuICAgICAgdmFyIGRldGFpbHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGRldGFpbHMuc2h1ZmZsZSA9IHRoaXM7XG4gICAgICByZXR1cm4gIXRoaXMuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICBkZXRhaWw6IGRldGFpbHNcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBaZXJvcyBvdXQgdGhlIHkgY29sdW1ucyBhcnJheSwgd2hpY2ggaXMgdXNlZCB0byBkZXRlcm1pbmUgaXRlbSBwbGFjZW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3Jlc2V0Q29scycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldENvbHMoKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuY29scztcbiAgICAgIHRoaXMucG9zaXRpb25zID0gW107XG4gICAgICB3aGlsZSAoaSkge1xuICAgICAgICBpIC09IDE7XG4gICAgICAgIHRoaXMucG9zaXRpb25zLnB1c2goMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9vcHMgdGhyb3VnaCBlYWNoIGl0ZW0gdGhhdCBzaG91bGQgYmUgc2hvd24gYW5kIGNhbGN1bGF0ZXMgdGhlIHgsIHkgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheS48U2h1ZmZsZUl0ZW0+fSBpdGVtcyBBcnJheSBvZiBpdGVtcyB0aGF0IHdpbGwgYmUgc2hvd24vbGF5ZWRcbiAgICAgKiAgICAgb3V0IGluIG9yZGVyIGluIHRoZWlyIGFycmF5LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfbGF5b3V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xheW91dChpdGVtcykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBjdXJyUG9zID0gaXRlbS5wb2ludDtcbiAgICAgICAgdmFyIGN1cnJTY2FsZSA9IGl0ZW0uc2NhbGU7XG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IFNodWZmbGUuZ2V0U2l6ZShpdGVtLmVsZW1lbnQsIHRydWUpO1xuICAgICAgICB2YXIgcG9zID0gX3RoaXMzLl9nZXRJdGVtUG9zaXRpb24oaXRlbVNpemUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgICAgIGl0ZW0uZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSAnJztcbiAgICAgICAgICBpdGVtLmFwcGx5Q3NzKFNodWZmbGVJdGVtLkNzcy5WSVNJQkxFLmFmdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBpdGVtIHdpbGwgbm90IGNoYW5nZSBpdHMgcG9zaXRpb24sIGRvIG5vdCBhZGQgaXQgdG8gdGhlIHJlbmRlclxuICAgICAgICAvLyBxdWV1ZS4gVHJhbnNpdGlvbnMgZG9uJ3QgZmlyZSB3aGVuIHNldHRpbmcgYSBwcm9wZXJ0eSB0byB0aGUgc2FtZSB2YWx1ZS5cbiAgICAgICAgaWYgKFBvaW50LmVxdWFscyhjdXJyUG9zLCBwb3MpICYmIGN1cnJTY2FsZSA9PT0gU2h1ZmZsZUl0ZW0uU2NhbGUuVklTSUJMRSkge1xuICAgICAgICAgIGl0ZW0uYXBwbHlDc3MoU2h1ZmZsZUl0ZW0uQ3NzLlZJU0lCTEUuYmVmb3JlKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0ucG9pbnQgPSBwb3M7XG4gICAgICAgIGl0ZW0uc2NhbGUgPSBTaHVmZmxlSXRlbS5TY2FsZS5WSVNJQkxFO1xuXG4gICAgICAgIC8vIFVzZSB4dGVuZCBoZXJlIHRvIGNsb25lIHRoZSBvYmplY3Qgc28gdGhhdCB0aGUgYGJlZm9yZWAgb2JqZWN0IGlzbid0XG4gICAgICAgIC8vIG1vZGlmaWVkIHdoZW4gdGhlIHRyYW5zaXRpb24gZGVsYXkgaXMgYWRkZWQuXG4gICAgICAgIHZhciBzdHlsZXMgPSBpbW11dGFibGUoU2h1ZmZsZUl0ZW0uQ3NzLlZJU0lCTEUuYmVmb3JlKTtcbiAgICAgICAgc3R5bGVzLnRyYW5zaXRpb25EZWxheSA9IF90aGlzMy5fZ2V0U3RhZ2dlckFtb3VudChjb3VudCkgKyAnbXMnO1xuXG4gICAgICAgIF90aGlzMy5fcXVldWUucHVzaCh7XG4gICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgbG9jYXRpb24gb2YgdGhlIG5leHQgaXRlbSwgYmFzZWQgb24gaXRzIHNpemUuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBpdGVtU2l6ZSBPYmplY3Qgd2l0aCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqIEByZXR1cm4ge1BvaW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRJdGVtUG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SXRlbVBvc2l0aW9uKGl0ZW1TaXplKSB7XG4gICAgICByZXR1cm4gZ2V0SXRlbVBvc2l0aW9uKHtcbiAgICAgICAgaXRlbVNpemU6IGl0ZW1TaXplLFxuICAgICAgICBwb3NpdGlvbnM6IHRoaXMucG9zaXRpb25zLFxuICAgICAgICBncmlkU2l6ZTogdGhpcy5jb2xXaWR0aCxcbiAgICAgICAgdG90YWw6IHRoaXMuY29scyxcbiAgICAgICAgdGhyZXNob2xkOiB0aGlzLm9wdGlvbnMuY29sdW1uVGhyZXNob2xkLFxuICAgICAgICBidWZmZXI6IHRoaXMub3B0aW9ucy5idWZmZXJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBlbGVtZW50cyB0aGF0IGRvbid0IG1hdGNoIG91ciBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheS48U2h1ZmZsZUl0ZW0+fSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gdG8gc2hyaW5rLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19zaHJpbmsnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hyaW5rKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBjb2xsZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLl9nZXRDb25jZWFsZWRJdGVtcygpO1xuXG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgICAgIGl0ZW0uYXBwbHlDc3MoU2h1ZmZsZUl0ZW0uQ3NzLkhJRERFTi5hZnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb250aW51aW5nIHdvdWxkIGFkZCBhIHRyYW5zaXRpb25lbmQgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGVsZW1lbnQsIGJ1dFxuICAgICAgICAvLyB0aGF0IGxpc3RlbmVyIHdvdWxkIG5vdCBleGVjdXRlIGJlY2F1c2UgdGhlIHRyYW5zZm9ybSBhbmQgb3BhY2l0eSB3b3VsZFxuICAgICAgICAvLyBzdGF5IHRoZSBzYW1lLlxuICAgICAgICAvLyBUaGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgaGVyZSBiZWNhdXNlIGl0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZFxuICAgICAgICAvLyBhZnRlciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCBiZWNhdXNlIHRoZSB0cmFuc2l0aW9uZW5kIGNvdWxkIGJlXG4gICAgICAgIC8vIGNhbmNlbGVkIGlmIGFub3RoZXIgYW5pbWF0aW9uIHN0YXJ0cy5cbiAgICAgICAgaWYgKGl0ZW0uc2NhbGUgPT09IFNodWZmbGVJdGVtLlNjYWxlLkhJRERFTikge1xuICAgICAgICAgIGl0ZW0uYXBwbHlDc3MoU2h1ZmZsZUl0ZW0uQ3NzLkhJRERFTi5iZWZvcmUpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5zY2FsZSA9IFNodWZmbGVJdGVtLlNjYWxlLkhJRERFTjtcblxuICAgICAgICB2YXIgc3R5bGVzID0gaW1tdXRhYmxlKFNodWZmbGVJdGVtLkNzcy5ISURERU4uYmVmb3JlKTtcbiAgICAgICAgc3R5bGVzLnRyYW5zaXRpb25EZWxheSA9IF90aGlzNC5fZ2V0U3RhZ2dlckFtb3VudChjb3VudCkgKyAnbXMnO1xuXG4gICAgICAgIF90aGlzNC5fcXVldWUucHVzaCh7XG4gICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBoYW5kbGVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVSZXNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlUmVzaXplKCkge1xuICAgICAgLy8gSWYgc2h1ZmZsZSBpcyBkaXNhYmxlZCwgZGVzdHJveWVkLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCB8fCB0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gV2lsbCBuZWVkIHRvIGNoZWNrIGhlaWdodCBpbiB0aGUgZnV0dXJlIGlmIGl0J3MgbGF5ZWQgb3V0IGhvcml6b250YWx5XG4gICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBTaHVmZmxlLmdldFNpemUodGhpcy5lbGVtZW50KS53aWR0aDtcblxuICAgICAgLy8gY29udGFpbmVyV2lkdGggaGFzbid0IGNoYW5nZWQsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICBpZiAoY29udGFpbmVyV2lkdGggPT09IHRoaXMuY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgYW4gaXRlbSBmb3IgYSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVHJhbnNpdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm4geyFPYmplY3R9IFRyYW5zZm9ybXMgZm9yIHRyYW5zaXRpb25zLCBsZWZ0L3RvcCBmb3IgYW5pbWF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0U3R5bGVzRm9yVHJhbnNpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdHlsZXNGb3JUcmFuc2l0aW9uKF9yZWYyKSB7XG4gICAgICB2YXIgaXRlbSA9IF9yZWYyLml0ZW0sXG4gICAgICAgICAgc3R5bGVzID0gX3JlZjIuc3R5bGVzO1xuXG4gICAgICBpZiAoIXN0eWxlcy50cmFuc2l0aW9uRGVsYXkpIHtcbiAgICAgICAgc3R5bGVzLnRyYW5zaXRpb25EZWxheSA9ICcwbXMnO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IGl0ZW0ucG9pbnQueDtcbiAgICAgIHZhciB5ID0gaXRlbS5wb2ludC55O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybXMpIHtcbiAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHggKyAncHgsICcgKyB5ICsgJ3B4KSBzY2FsZSgnICsgaXRlbS5zY2FsZSArICcpJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlcy5sZWZ0ID0geCArICdweCc7XG4gICAgICAgIHN0eWxlcy50b3AgPSB5ICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZm9yIHRoZSB0cmFuc2l0aW9uIGVuZCBvbiBhbiBlbGVtZW50IGFuZCBleGVjdXRlIHRoZSBpdGVtQ2FsbGJhY2tcbiAgICAgKiB3aGVuIGl0IGZpbmlzaGVzLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGxpc3RlbiBvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVtQ2FsbGJhY2sgQ2FsbGJhY2sgZm9yIHRoZSBpdGVtLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQ2FsbGJhY2sgdG8gbm90aWZ5IGBwYXJhbGxlbGAgdGhhdCB0aGlzIG9uZSBpcyBkb25lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfd2hlblRyYW5zaXRpb25Eb25lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3doZW5UcmFuc2l0aW9uRG9uZShlbGVtZW50LCBpdGVtQ2FsbGJhY2ssIGRvbmUpIHtcbiAgICAgIHZhciBpZCA9IG9uVHJhbnNpdGlvbkVuZChlbGVtZW50LCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGl0ZW1DYWxsYmFjaygpO1xuICAgICAgICBkb25lKG51bGwsIGV2dCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fdHJhbnNpdGlvbnMucHVzaChpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBzZXQgQ1NTIHN0eWxlcyBhbmQgY2FsbCB0aGUgYGRvbmVgIGZ1bmN0aW9uXG4gICAgICogd2hlbiAoaWYpIHRoZSB0cmFuc2l0aW9uIGZpbmlzaGVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRyYW5zaXRpb24gb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIGEgYGRvbmVgIGZ1bmN0aW9uLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0VHJhbnNpdGlvbkZ1bmN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zaXRpb25GdW5jdGlvbihvcHRzKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgIG9wdHMuaXRlbS5hcHBseUNzcyhfdGhpczUuX2dldFN0eWxlc0ZvclRyYW5zaXRpb24ob3B0cykpO1xuICAgICAgICBfdGhpczUuX3doZW5UcmFuc2l0aW9uRG9uZShvcHRzLml0ZW0uZWxlbWVudCwgb3B0cy5jYWxsYmFjaywgZG9uZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIHN0eWxlcyBnYXRoZXJlZCBpbiB0aGUgc3R5bGUgcXVldWUuIFRoaXMgYXBwbGllcyBzdHlsZXMgdG8gZWxlbWVudHMsXG4gICAgICogdHJpZ2dlcmluZyB0cmFuc2l0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcHJvY2Vzc1F1ZXVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NRdWV1ZSgpIHtcbiAgICAgIGlmICh0aGlzLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICB0aGlzLl9jYW5jZWxNb3ZlbWVudCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzU3BlZWQgPSB0aGlzLm9wdGlvbnMuc3BlZWQgPiAwO1xuICAgICAgdmFyIGhhc1F1ZXVlID0gdGhpcy5fcXVldWUubGVuZ3RoID4gMDtcblxuICAgICAgaWYgKGhhc1F1ZXVlICYmIGhhc1NwZWVkICYmIHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLl9zdGFydFRyYW5zaXRpb25zKHRoaXMuX3F1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzUXVldWUpIHtcbiAgICAgICAgdGhpcy5fc3R5bGVJbW1lZGlhdGVseSh0aGlzLl9xdWV1ZSk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoTGF5b3V0KCk7XG5cbiAgICAgICAgLy8gQSBjYWxsIHRvIGxheW91dCBoYXBwZW5lZCwgYnV0IG5vbmUgb2YgdGhlIG5ld2x5IHZpc2libGUgaXRlbXMgd2lsbFxuICAgICAgICAvLyBjaGFuZ2UgcG9zaXRpb24gb3IgdGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgemVybywgd2hpY2ggd2lsbCBub3QgdHJpZ2dlclxuICAgICAgICAvLyB0aGUgdHJhbnNpdGlvbmVuZCBldmVudC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoTGF5b3V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIGluIHRoZSBzdHlsZSBxdWV1ZVxuICAgICAgdGhpcy5fcXVldWUubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXYWl0IGZvciBlYWNoIHRyYW5zaXRpb24gdG8gZmluaXNoLCB0aGUgZW1pdCB0aGUgbGF5b3V0IGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHRyYW5zaXRpb25zIEFycmF5IG9mIHRyYW5zaXRpb24gb2JqZWN0cy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3N0YXJ0VHJhbnNpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRUcmFuc2l0aW9ucyh0cmFuc2l0aW9ucykge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldCBmbGFnIHRoYXQgc2h1ZmZsZSBpcyBjdXJyZW50bHkgaW4gbW90aW9uLlxuICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGJlIGNhbGxlZC5cbiAgICAgIHZhciBjYWxsYmFja3MgPSB0cmFuc2l0aW9ucy5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gX3RoaXM2Ll9nZXRUcmFuc2l0aW9uRnVuY3Rpb24ob2JqKTtcbiAgICAgIH0pO1xuXG4gICAgICBpbmRleCQzKGNhbGxiYWNrcywgdGhpcy5fbW92ZW1lbnRGaW5pc2hlZC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY2FuY2VsTW92ZW1lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FuY2VsTW92ZW1lbnQoKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHRyYW5zaXRpb24gZW5kIGV2ZW50IGZvciBlYWNoIGxpc3RlbmVyLlxuICAgICAgdGhpcy5fdHJhbnNpdGlvbnMuZm9yRWFjaChjYW5jZWxUcmFuc2l0aW9uRW5kKTtcblxuICAgICAgLy8gUmVzZXQgdGhlIGFycmF5LlxuICAgICAgdGhpcy5fdHJhbnNpdGlvbnMubGVuZ3RoID0gMDtcblxuICAgICAgLy8gU2hvdyBpdCdzIG5vIGxvbmdlciBhY3RpdmUuXG4gICAgICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHN0eWxlcyB3aXRob3V0IGEgdHJhbnNpdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBvYmplY3RzIEFycmF5IG9mIHRyYW5zaXRpb24gb2JqZWN0cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfc3R5bGVJbW1lZGlhdGVseScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdHlsZUltbWVkaWF0ZWx5KG9iamVjdHMpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICBpZiAob2JqZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gb2JqZWN0cy5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmouaXRlbS5lbGVtZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICBTaHVmZmxlLl9za2lwVHJhbnNpdGlvbnMoZWxlbWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgb2JqLml0ZW0uYXBwbHlDc3MoX3RoaXM3Ll9nZXRTdHlsZXNGb3JUcmFuc2l0aW9uKG9iaikpO1xuICAgICAgICAgICAgb2JqLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19tb3ZlbWVudEZpbmlzaGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVtZW50RmluaXNoZWQoKSB7XG4gICAgICB0aGlzLl90cmFuc2l0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoTGF5b3V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2Rpc3BhdGNoTGF5b3V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3BhdGNoTGF5b3V0KCkge1xuICAgICAgdGhpcy5fZGlzcGF0Y2goU2h1ZmZsZS5FdmVudFR5cGUuTEFZT1VUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFnaWMuIFRoaXMgaXMgd2hhdCBtYWtlcyB0aGUgcGx1Z2luICdzaHVmZmxlJ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufEFycmF5LjxzdHJpbmc+fSBbY2F0ZWdvcnldIENhdGVnb3J5IHRvIGZpbHRlciBieS5cbiAgICAgKiAgICAgQ2FuIGJlIGEgZnVuY3Rpb24sIHN0cmluZywgb3IgYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3NvcnRPYmpdIEEgc29ydCBvYmplY3Qgd2hpY2ggY2FuIHNvcnQgdGhlIHZpc2libGUgc2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbHRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihjYXRlZ29yeSwgc29ydE9iaikge1xuICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghY2F0ZWdvcnkgfHwgY2F0ZWdvcnkgJiYgY2F0ZWdvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhdGVnb3J5ID0gU2h1ZmZsZS5BTExfSVRFTVM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIH1cblxuICAgICAgdGhpcy5fZmlsdGVyKGNhdGVnb3J5KTtcblxuICAgICAgLy8gU2hyaW5rIGVhY2ggaGlkZGVuIGl0ZW1cbiAgICAgIHRoaXMuX3NocmluaygpO1xuXG4gICAgICAvLyBIb3cgbWFueSB2aXNpYmxlIGVsZW1lbnRzP1xuICAgICAgdGhpcy5fdXBkYXRlSXRlbUNvdW50KCk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0cmFuc2Zvcm1zIG9uIHZpc2libGUgZWxlbWVudHMgc28gdGhleSB3aWxsIGFuaW1hdGUgdG8gdGhlaXIgbmV3IHBvc2l0aW9ucy5cbiAgICAgIHRoaXMuc29ydChzb3J0T2JqKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aXNpYmxlIGVsZW1lbnRzLCBzb3J0cyB0aGVtLCBhbmQgcGFzc2VzIHRoZW0gdG8gbGF5b3V0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIHRoZSBvcHRpb25zIG9iamVjdCBmb3IgdGhlIHNvcnRlZCBwbHVnaW5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc29ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5sYXN0U29ydDtcblxuICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Jlc2V0Q29scygpO1xuXG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLl9nZXRGaWx0ZXJlZEl0ZW1zKCk7XG4gICAgICBpdGVtcyA9IHNvcnRlcihpdGVtcywgb3B0cyk7XG5cbiAgICAgIHRoaXMuX2xheW91dChpdGVtcyk7XG5cbiAgICAgIC8vIGBfbGF5b3V0YCBhbHdheXMgaGFwcGVucyBhZnRlciBgX3Nocmlua2AsIHNvIGl0J3Mgc2FmZSB0byBwcm9jZXNzIHRoZSBzdHlsZVxuICAgICAgLy8gcXVldWUgaGVyZSB3aXRoIHN0eWxlcyBmcm9tIHRoZSBzaHJpbmsgbWV0aG9kLlxuICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG5cbiAgICAgIC8vIEFkanVzdCB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXG4gICAgICB0aGlzLl9zZXRDb250YWluZXJTaXplKCk7XG5cbiAgICAgIHRoaXMubGFzdFNvcnQgPSBvcHRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcG9zaXRpb24gZXZlcnl0aGluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzT25seUxheW91dCBJZiB0cnVlLCBjb2x1bW4gYW5kIGd1dHRlciB3aWR0aHMgd29uJ3QgYmVcbiAgICAgKiAgICAgcmVjYWxjdWxhdGVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoaXNPbmx5TGF5b3V0KSB7XG4gICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKCFpc09ubHlMYXlvdXQpIHtcbiAgICAgICAgICAvLyBHZXQgdXBkYXRlZCBjb2xDb3VudFxuICAgICAgICAgIHRoaXMuX3NldENvbHVtbnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExheW91dCBpdGVtc1xuICAgICAgICB0aGlzLnNvcnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBpbnN0ZWFkIG9mIGB1cGRhdGUoKWAgaWYgeW91IGRvbid0IG5lZWQgdGhlIGNvbHVtbnMgYW5kIGd1dHRlcnMgdXBkYXRlZFxuICAgICAqIE1heWJlIGFuIGltYWdlIGluc2lkZSBgc2h1ZmZsZWAgbG9hZGVkIChhbmQgbm93IGhhcyBhIGhlaWdodCksIHdoaWNoIG1lYW5zIGNhbGN1bGF0aW9uc1xuICAgICAqIGNvdWxkIGJlIG9mZi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGF5b3V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0KCkge1xuICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmV3IGl0ZW1zIGhhdmUgYmVlbiBhcHBlbmRlZCB0byBzaHVmZmxlLiBNaXggdGhlbSBpbiB3aXRoIHRoZSBjdXJyZW50XG4gICAgICogZmlsdGVyIG9yIHNvcnQgc3RhdHVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnQ+fSBuZXdJdGVtcyBDb2xsZWN0aW9uIG9mIG5ldyBpdGVtcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKG5ld0l0ZW1zKSB7XG4gICAgICB2YXIgaXRlbXMgPSBpbmRleCQxKG5ld0l0ZW1zKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2h1ZmZsZUl0ZW0oZWwpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBjbGFzc2VzIGFuZCBzZXQgaW5pdGlhbCBwb3NpdGlvbnMuXG4gICAgICB0aGlzLl9pbml0SXRlbXMoaXRlbXMpO1xuXG4gICAgICAvLyBBZGQgdHJhbnNpdGlvbiB0byBlYWNoIGl0ZW0uXG4gICAgICB0aGlzLl9zZXRUcmFuc2l0aW9ucyhpdGVtcyk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgbGlzdCBvZiBpdGVtcy5cbiAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLmNvbmNhdChpdGVtcyk7XG4gICAgICB0aGlzLl91cGRhdGVJdGVtc09yZGVyKCk7XG4gICAgICB0aGlzLmZpbHRlcih0aGlzLmxhc3RGaWx0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHNodWZmbGUgZnJvbSB1cGRhdGluZyBkaW1lbnNpb25zIGFuZCBsYXlvdXQgb24gcmVzaXplXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHNodWZmbGUgYWdhaW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1VwZGF0ZUxheW91dD10cnVlXSBpZiB1bmRlZmluZWQsIHNodWZmbGUgd2lsbCB1cGRhdGUgY29sdW1ucyBhbmQgZ3V0dGVyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoaXNVcGRhdGVMYXlvdXQpIHtcbiAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGlmIChpc1VwZGF0ZUxheW91dCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgMSBvciBtb3JlIHNodWZmbGUgaXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50Pn0gZWxlbWVudHMgQW4gYXJyYXkgY29udGFpbmluZyBvbmUgb3IgbW9yZVxuICAgICAqICAgICBlbGVtZW50cyBpbiBzaHVmZmxlXG4gICAgICogQHJldHVybiB7U2h1ZmZsZX0gVGhlIHNodWZmbGUgb2JqZWN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50cykge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSBpbmRleCQxKGVsZW1lbnRzKTtcblxuICAgICAgdmFyIG9sZEl0ZW1zID0gY29sbGVjdGlvbi5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOC5nZXRJdGVtQnlFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiAhIWl0ZW07XG4gICAgICB9KTtcblxuICAgICAgdmFyIGhhbmRsZUxheW91dCA9IGZ1bmN0aW9uIGhhbmRsZUxheW91dCgpIHtcbiAgICAgICAgX3RoaXM4LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihTaHVmZmxlLkV2ZW50VHlwZS5MQVlPVVQsIGhhbmRsZUxheW91dCk7XG4gICAgICAgIF90aGlzOC5fZGlzcG9zZUl0ZW1zKG9sZEl0ZW1zKTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGNvbGxlY3Rpb24gaW4gdGhlIGNhbGxiYWNrXG4gICAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXM4Ll9kaXNwYXRjaChTaHVmZmxlLkV2ZW50VHlwZS5SRU1PVkVELCB7IGNvbGxlY3Rpb246IGNvbGxlY3Rpb24gfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBIaWRlIGNvbGxlY3Rpb24gZmlyc3QuXG4gICAgICB0aGlzLl90b2dnbGVGaWx0ZXJDbGFzc2VzKHtcbiAgICAgICAgdmlzaWJsZTogW10sXG4gICAgICAgIGhpZGRlbjogb2xkSXRlbXNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9zaHJpbmsob2xkSXRlbXMpO1xuXG4gICAgICB0aGlzLnNvcnQoKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBsaXN0IG9mIGl0ZW1zIGhlcmUgYmVjYXVzZSBgcmVtb3ZlYCBjb3VsZCBiZSBjYWxsZWQgYWdhaW5cbiAgICAgIC8vIHdpdGggYW4gaXRlbSB0aGF0IGlzIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIHJlbW92ZWQuXG4gICAgICB0aGlzLml0ZW1zID0gdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICFhcnJheUluY2x1ZGVzKG9sZEl0ZW1zLCBpdGVtKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fdXBkYXRlSXRlbUNvdW50KCk7XG5cbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFNodWZmbGUuRXZlbnRUeXBlLkxBWU9VVCwgaGFuZGxlTGF5b3V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIHNodWZmbGUgaXRlbSBieSBpdHMgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsb29rIGZvci5cbiAgICAgKiBAcmV0dXJuIHs/U2h1ZmZsZUl0ZW19IEEgc2h1ZmZsZSBpdGVtIG9yIG51bGwgaWYgaXQncyBub3QgZm91bmQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEl0ZW1CeUVsZW1lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJdGVtQnlFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zW2ldLmVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBzaHVmZmxlLCByZW1vdmVzIGV2ZW50cywgc3R5bGVzLCBhbmQgY2xhc3Nlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX2NhbmNlbE1vdmVtZW50KCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuXG4gICAgICAvLyBSZXNldCBjb250YWluZXIgc3R5bGVzXG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc2h1ZmZsZScpO1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgLy8gUmVzZXQgaW5kaXZpZHVhbCBpdGVtIHN0eWxlc1xuICAgICAgdGhpcy5fZGlzcG9zZUl0ZW1zKCk7XG5cbiAgICAgIC8vIE51bGwgRE9NIHJlZmVyZW5jZXNcbiAgICAgIHRoaXMuaXRlbXMgPSBudWxsO1xuICAgICAgdGhpcy5vcHRpb25zLnNpemVyID0gbnVsbDtcbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl90cmFuc2l0aW9ucyA9IG51bGw7XG5cbiAgICAgIC8vIFNldCBhIGZsYWcgc28gaWYgYSBkZWJvdW5jZWQgcmVzaXplIGhhcyBiZWVuIHRyaWdnZXJlZCxcbiAgICAgIC8vIGl0IGNhbiBmaXJzdCBjaGVjayBpZiBpdCBpcyBhY3R1YWxseSBpc0Rlc3Ryb3llZCBhbmQgbm90IGRvaW5nIGFueXRoaW5nXG4gICAgICB0aGlzLmlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdXRlciB3aWR0aCBvZiBhbiBlbGVtZW50LCBvcHRpb25hbGx5IGluY2x1ZGluZyBpdHMgbWFyZ2lucy5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSBhIGZldyBkaWZmZXJlbnQgbWV0aG9kcyBmb3IgZ2V0dGluZyB0aGUgd2lkdGggb2YgYW4gZWxlbWVudCwgbm9uZSBvZlxuICAgICAqIHdoaWNoIHdvcmsgcGVyZmVjdGx5IGZvciBhbGwgU2h1ZmZsZSdzIHVzZSBjYXNlcy5cbiAgICAgKlxuICAgICAqIDEuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGBsZWZ0YCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzLlxuICAgICAqICAgLSBBY2NvdW50cyBmb3IgdHJhbnNmb3JtIHNjYWxlZCBlbGVtZW50cywgbWFraW5nIGl0IHVzZWxlc3MgZm9yIFNodWZmbGVcbiAgICAgKiAgIGVsZW1lbnRzIHdoaWNoIGhhdmUgc2hydW5rLlxuICAgICAqIDIuIFRoZSBgb2Zmc2V0V2lkdGhgIHByb3BlcnR5LlxuICAgICAqICAgLSBUaGlzIHZhbHVlIHN0YXlzIHRoZSBzYW1lIHJlZ2FyZGxlc3Mgb2YgdGhlIGVsZW1lbnRzIHRyYW5zZm9ybSBwcm9wZXJ0eSxcbiAgICAgKiAgIGhvd2V2ZXIsIGl0IGRvZXMgbm90IHJldHVybiBzdWJwaXhlbCB2YWx1ZXMuXG4gICAgICogMy4gZ2V0Q29tcHV0ZWRTdHlsZSgpXG4gICAgICogICAtIFRoaXMgd29ya3MgZ3JlYXQgQ2hyb21lLCBGaXJlZm94LCBTYWZhcmksIGJ1dCBJRTw9MTEgZG9lcyBub3QgaW5jbHVkZVxuICAgICAqICAgcGFkZGluZyBhbmQgYm9yZGVyIHdoZW4gYm94LXNpemluZzogYm9yZGVyLWJveCBpcyBzZXQsIHJlcXVpcmluZyBhIGZlYXR1cmVcbiAgICAgKiAgIHRlc3QgYW5kIGV4dHJhIHdvcmsgdG8gYWRkIHRoZSBwYWRkaW5nIGJhY2sgZm9yIElFIGFuZCBvdGhlciBicm93c2VycyB3aGljaFxuICAgICAqICAgZm9sbG93IHRoZSBXM0Mgc3BlYyBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVNYXJnaW5zXSBXaGV0aGVyIHRvIGluY2x1ZGUgbWFyZ2lucy4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgKiBAcmV0dXJuIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBUaGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6ICdnZXRTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2l6ZShlbGVtZW50LCBpbmNsdWRlTWFyZ2lucykge1xuICAgICAgLy8gU3RvcmUgdGhlIHN0eWxlcyBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgYnkgb3RoZXJzIHdpdGhvdXQgYXNraW5nIGZvciBpdCBhZ2Fpbi5cbiAgICAgIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICAgIHZhciB3aWR0aCA9IGdldE51bWJlclN0eWxlKGVsZW1lbnQsICd3aWR0aCcsIHN0eWxlcyk7XG4gICAgICB2YXIgaGVpZ2h0ID0gZ2V0TnVtYmVyU3R5bGUoZWxlbWVudCwgJ2hlaWdodCcsIHN0eWxlcyk7XG5cbiAgICAgIGlmIChpbmNsdWRlTWFyZ2lucykge1xuICAgICAgICB2YXIgbWFyZ2luTGVmdCA9IGdldE51bWJlclN0eWxlKGVsZW1lbnQsICdtYXJnaW5MZWZ0Jywgc3R5bGVzKTtcbiAgICAgICAgdmFyIG1hcmdpblJpZ2h0ID0gZ2V0TnVtYmVyU3R5bGUoZWxlbWVudCwgJ21hcmdpblJpZ2h0Jywgc3R5bGVzKTtcbiAgICAgICAgdmFyIG1hcmdpblRvcCA9IGdldE51bWJlclN0eWxlKGVsZW1lbnQsICdtYXJnaW5Ub3AnLCBzdHlsZXMpO1xuICAgICAgICB2YXIgbWFyZ2luQm90dG9tID0gZ2V0TnVtYmVyU3R5bGUoZWxlbWVudCwgJ21hcmdpbkJvdHRvbScsIHN0eWxlcyk7XG4gICAgICAgIHdpZHRoICs9IG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodDtcbiAgICAgICAgaGVpZ2h0ICs9IG1hcmdpblRvcCArIG1hcmdpbkJvdHRvbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgYSBwcm9wZXJ0eSBvciBleGVjdXRlIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIHRyYW5zaXRpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50Pn0gZWxlbWVudHMgRE9NIGVsZW1lbnRzIHRoYXQgd29uJ3QgYmUgdHJhbnNpdGlvbmVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2hpbGUgdHJhbnNpdGlvblxuICAgICAqICAgICBpcyBzZXQgdG8gMG1zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19za2lwVHJhbnNpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2tpcFRyYW5zaXRpb25zKGVsZW1lbnRzLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHplcm8gPSAnMG1zJztcblxuICAgICAgLy8gU2F2ZSBjdXJyZW50IGR1cmF0aW9uIGFuZCBkZWxheS5cbiAgICAgIHZhciBkYXRhID0gZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgdmFyIGRlbGF5ID0gc3R5bGUudHJhbnNpdGlvbkRlbGF5O1xuXG4gICAgICAgIC8vIFNldCB0aGUgZHVyYXRpb24gdG8gemVybyBzbyBpdCBoYXBwZW5zIGltbWVkaWF0ZWx5XG4gICAgICAgIHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHplcm87XG4gICAgICAgIHN0eWxlLnRyYW5zaXRpb25EZWxheSA9IHplcm87XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgZGVsYXk6IGRlbGF5XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgY2FsbGJhY2soKTtcblxuICAgICAgLy8gQ2F1c2UgcmVmbG93LlxuICAgICAgZWxlbWVudHNbMF0ub2Zmc2V0V2lkdGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgICAgIC8vIFB1dCB0aGUgZHVyYXRpb24gYmFja1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGRhdGFbaV0uZHVyYXRpb247XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gZGF0YVtpXS5kZWxheTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2h1ZmZsZTtcbn0oKTtcblxuU2h1ZmZsZS5TaHVmZmxlSXRlbSA9IFNodWZmbGVJdGVtO1xuXG5TaHVmZmxlLkFMTF9JVEVNUyA9ICdhbGwnO1xuU2h1ZmZsZS5GSUxURVJfQVRUUklCVVRFX0tFWSA9ICdncm91cHMnO1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cblNodWZmbGUuRXZlbnRUeXBlID0ge1xuICBMQVlPVVQ6ICdzaHVmZmxlOmxheW91dCcsXG4gIFJFTU9WRUQ6ICdzaHVmZmxlOnJlbW92ZWQnXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cblNodWZmbGUuQ2xhc3NlcyA9IENsYXNzZXM7XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuU2h1ZmZsZS5GaWx0ZXJNb2RlID0ge1xuICBBTlk6ICdhbnknLFxuICBBTEw6ICdhbGwnXG59O1xuXG4vLyBPdmVycmlkZWFibGUgb3B0aW9uc1xuU2h1ZmZsZS5vcHRpb25zID0ge1xuICAvLyBJbml0aWFsIGZpbHRlciBncm91cC5cbiAgZ3JvdXA6IFNodWZmbGUuQUxMX0lURU1TLFxuXG4gIC8vIFRyYW5zaXRpb24vYW5pbWF0aW9uIHNwZWVkIChtaWxsaXNlY29uZHMpLlxuICBzcGVlZDogMjUwLFxuXG4gIC8vIENTUyBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlLlxuICBlYXNpbmc6ICdlYXNlJyxcblxuICAvLyBlLmcuICcucGljdHVyZS1pdGVtJy5cbiAgaXRlbVNlbGVjdG9yOiAnKicsXG5cbiAgLy8gRWxlbWVudCBvciBzZWxlY3RvciBzdHJpbmcuIFVzZSBhbiBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgc2l6ZSBvZiBjb2x1bW5zXG4gIC8vIGFuZCBndXR0ZXJzLlxuICBzaXplcjogbnVsbCxcblxuICAvLyBBIHN0YXRpYyBudW1iZXIgb3IgZnVuY3Rpb24gdGhhdCB0ZWxscyB0aGUgcGx1Z2luIGhvdyB3aWRlIHRoZSBndXR0ZXJzXG4gIC8vIGJldHdlZW4gY29sdW1ucyBhcmUgKGluIHBpeGVscykuXG4gIGd1dHRlcldpZHRoOiAwLFxuXG4gIC8vIEEgc3RhdGljIG51bWJlciBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBudW1iZXIgd2hpY2ggdGVsbHMgdGhlIHBsdWdpblxuICAvLyBob3cgd2lkZSB0aGUgY29sdW1ucyBhcmUgKGluIHBpeGVscykuXG4gIGNvbHVtbldpZHRoOiAwLFxuXG4gIC8vIElmIHlvdXIgZ3JvdXAgaXMgbm90IGpzb24sIGFuZCBpcyBjb21tYSBkZWxpbWV0ZWQsIHlvdSBjb3VsZCBzZXQgZGVsaW1ldGVyXG4gIC8vIHRvICcsJy5cbiAgZGVsaW1ldGVyOiBudWxsLFxuXG4gIC8vIFVzZWZ1bCBmb3IgcGVyY2VudGFnZSBiYXNlZCBoZWlnaHRzIHdoZW4gdGhleSBtaWdodCBub3QgYWx3YXlzIGJlIGV4YWN0bHlcbiAgLy8gdGhlIHNhbWUgKGluIHBpeGVscykuXG4gIGJ1ZmZlcjogMCxcblxuICAvLyBSZWFkaW5nIHRoZSB3aWR0aCBvZiBlbGVtZW50cyBpc24ndCBwcmVjaXNlIGVub3VnaCBhbmQgY2FuIGNhdXNlIGNvbHVtbnMgdG9cbiAgLy8ganVtcCBiZXR3ZWVuIHZhbHVlcy5cbiAgY29sdW1uVGhyZXNob2xkOiAwLjAxLFxuXG4gIC8vIFNodWZmbGUgY2FuIGJlIGlzSW5pdGlhbGl6ZWQgd2l0aCBhIHNvcnQgb2JqZWN0LiBJdCBpcyB0aGUgc2FtZSBvYmplY3RcbiAgLy8gZ2l2ZW4gdG8gdGhlIHNvcnQgbWV0aG9kLlxuICBpbml0aWFsU29ydDogbnVsbCxcblxuICAvLyBCeSBkZWZhdWx0LCBzaHVmZmxlIHdpbGwgdGhyb3R0bGUgcmVzaXplIGV2ZW50cy4gVGhpcyBjYW4gYmUgY2hhbmdlZCBvclxuICAvLyByZW1vdmVkLlxuICB0aHJvdHRsZTogaW5kZXgkMixcblxuICAvLyBIb3cgb2Z0ZW4gc2h1ZmZsZSBjYW4gYmUgY2FsbGVkIG9uIHJlc2l6ZSAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgdGhyb3R0bGVUaW1lOiAzMDAsXG5cbiAgLy8gVHJhbnNpdGlvbiBkZWxheSBvZmZzZXQgZm9yIGVhY2ggaXRlbSBpbiBtaWxsaXNlY29uZHMuXG4gIHN0YWdnZXJBbW91bnQ6IDE1LFxuXG4gIC8vIE1heGltdW0gc3RhZ2dlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuXG4gIHN0YWdnZXJBbW91bnRNYXg6IDI1MCxcblxuICAvLyBXaGV0aGVyIHRvIHVzZSB0cmFuc2Zvcm1zIG9yIGFic29sdXRlIHBvc2l0aW9uaW5nLlxuICB1c2VUcmFuc2Zvcm1zOiB0cnVlLFxuXG4gIC8vIEFmZmVjdHMgdXNpbmcgYW4gYXJyYXkgd2l0aCBmaWx0ZXIuIGUuZy4gYGZpbHRlcihbJ29uZScsICd0d28nXSlgLiBXaXRoIFwiYW55XCIsXG4gIC8vIHRoZSBlbGVtZW50IHBhc3NlcyB0aGUgdGVzdCBpZiBhbnkgb2YgaXRzIGdyb3VwcyBhcmUgaW4gdGhlIGFycmF5LiBXaXRoIFwiYWxsXCIsXG4gIC8vIHRoZSBlbGVtZW50IG9ubHkgcGFzc2VzIGlmIGFsbCBncm91cHMgYXJlIGluIHRoZSBhcnJheS5cbiAgZmlsdGVyTW9kZTogU2h1ZmZsZS5GaWx0ZXJNb2RlLkFOWVxufTtcblxuLy8gRXhwb3NlIGZvciB0ZXN0aW5nLiBIYWNrIGF0IHlvdXIgb3duIHJpc2suXG5TaHVmZmxlLl9fUG9pbnQgPSBQb2ludDtcblNodWZmbGUuX19zb3J0ZXIgPSBzb3J0ZXI7XG5TaHVmZmxlLl9fZ2V0Q29sdW1uU3BhbiA9IGdldENvbHVtblNwYW47XG5TaHVmZmxlLl9fZ2V0QXZhaWxhYmxlUG9zaXRpb25zID0gZ2V0QXZhaWxhYmxlUG9zaXRpb25zO1xuU2h1ZmZsZS5fX2dldFNob3J0Q29sdW1uID0gZ2V0U2hvcnRDb2x1bW47XG5cbnJldHVybiBTaHVmZmxlO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2h1ZmZsZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaHVmZmxlanMvZGlzdC9zaHVmZmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ })
/******/ ]);